<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis</title>
      <link href="/2024/03/15/redis/"/>
      <url>/2024/03/15/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><pre><code>——关系型数据库    关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。 包含Mysql、Oracle、SqlServer等。随着互联网WEB2.0时代的到来，面临着高并发、高性能的一系列的挑战。——非关系型数据库    新型的数据库模型，也被称为NOSQL数据库，NOSQL本意是“NOT ONLY SQL”，并不是彻底要彻底否定关系型数据库，而是作为传统关系型数据库的一个有效补充。包含 memcached （纯内存），redis（持久化缓存），mongodb（文档的数据库） </code></pre><hr><h1 id="非关系型数据库的分类"><a href="#非关系型数据库的分类" class="headerlink" title="非关系型数据库的分类"></a>非关系型数据库的分类</h1><pre><code>1、key-value存储数据库   键值数据库就类似传统语言中使用哈希表，可以通过key来添加、查询或删除数据，因为使用key主键访问，所以会获得很高的性能及扩展性 。典型产品：Memcached、Redis、MemcacheDB、BerkeleyDB 2、列存储（Column-oriedted）数据库  了解即可，一般公司用不到，典型产品：Cassandra,HBase 3、面向文档（Document-Oriented）数据库  面向文档数据库会将数据以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。典型产品：MorgoDB、CouchDB 4、图形（Graph）数据库</code></pre><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><pre><code>Window下安装：下载地址：https://github.com/MSOpenTech/redis/releases选择64位的ZIP压缩包点击下载，下载完成后解压，并将解压后的文件夹重命名为redis，方便后面使用</code></pre><h1 id="运行Redis服务"><a href="#运行Redis服务" class="headerlink" title="运行Redis服务"></a>运行Redis服务</h1><pre><code>1、使用cmd命令行进入解压后的redis目录2、在redis目录下 运行redis-server redis.windows.conf，启动redis服务，此时当关闭命令窗口redis服务也会关闭，其中后面的redis.window.conf可以省略将Redis配成windows服务3、可以将redis服务安装成windows服务，在redis目录下的命令窗口输入：redis-server --service-install redis.windows.conf即可4、查看服务是否配置成功，右键计算机—管理—服务，查找是否有Redis服务，如果启动，代表windows上的redis服务已经配置成功，redis服务已经启动。</code></pre><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><pre><code>启动本机Redis客户端：redis–cli ，此命令连接到本机的Redis服务，同时用PING命令检测本机Redis服务是否启动连接远程Redis服务： redis–cli –h host –p port –a “password”其中host为远程主机IP地址Port为远程Redis服务端口号Password为远程Redis服务密码用客户端连接了redis服务之后，就可以在当前命令行里使用redis命令来操作redis数据库了</code></pre><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><pre><code>1.Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(有序集合)。2.String（字符串）（最常用）string是redis最基本的类型，是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。3.Hash（哈希）（常用）Redis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 key和 value 的映射表，hash 特别适合用于存储对象，相当于java中的Map集合。4.List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。5.Set（集合）Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。6.zset(sorted set：有序集合)（了解）Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</code></pre><h1 id="Redis键命令"><a href="#Redis键命令" class="headerlink" title="Redis键命令"></a>Redis键命令</h1><pre><code>SET keyname value     新建一个键值对，keyname为键名，value为存储的值DEL keyname     删除一个已存在的key，keyname为键名，成功返回1，失败返回0EXISTS keyname    判断一个key是否存在，keyname为键名，RENAME key newkey    重命名一个已存在的key，key为原来的键名，newkey为新键名EXPIRE key seconds    给一个已存在的key设置过期时间，key为键名，seconds为秒数PERSIST keyname    移除key的过期时间，key将永久保持，keyname为键名TTL keyname    以毫秒数返回key的剩余时间，keyname为键名RANDOMKEY     从当前数据库随机返回一个key</code></pre><h1 id="Redis字符串命令"><a href="#Redis字符串命令" class="headerlink" title="Redis字符串命令"></a>Redis字符串命令</h1><pre><code>SET keyname value    设置一个键值对，keyname为键名，value为存储的值GET keyname    获取指定key对应的值，keyname为键名GETSET keyname value    将指定key的值设为value，同时返回该key原来的旧值MGET key1 key2…..    获取所有给定key的值GETRANGE key start end    获取指定key里的截取字符串，start为起始位置，end为结束位置STRLEN keyname    获取指定key里存储字符串的长度INCR keyname    给指定key里存储的数字增1APPEND keyname value    给指定key里存储的字符串末尾追加value</code></pre><h1 id="Redis哈希（hash）命令"><a href="#Redis哈希（hash）命令" class="headerlink" title="Redis哈希（hash）命令"></a>Redis哈希（hash）命令</h1><pre><code>HMSET key field1 “value1”…    同时将多个 field-value (域-值)对设置到哈希表 key 中HDEL key field1 field2…..    删除指定key哈希表的一个或者多个字段，key为哈希表的键，field1为哈希表里的字段名HEXISTS key field    查看指定key的哈希表内是否存在field字段HGET key field    获取指定key的哈希表内的field字段存储的值HGETALL key    获取指定key的哈希表的所有字段和值HKEYS key    获取指定key的哈希表中所有的字段HMGET key field1 field2…    获取指定key的哈希表中所有指定字段的值HVALS key    获取指定key的哈希表中所有的值</code></pre><h1 id="Redis列表（List）命令"><a href="#Redis列表（List）命令" class="headerlink" title="Redis列表（List）命令"></a>Redis列表（List）命令</h1><pre><code>LPUSH key value1 value2…    同时将一个或多个值插入到列表头部，设定的key即为列表的键LPUSH key value1 value2…    同时将一个或多个值插入到已存在的key对应的列表头部LPOP key    移出并获取指定key的列表中的第一个元素LINDEX key index    通过索引获取指定key的列表中的元素，index从0开始LRANGE key start stop    通过索引获取指定key的列表中某个范围的元素RPOP key    移出并获取指定key的列表中最后一个元素LREM key count value    移出指定key的列表中，与value相等的元素 count&gt;0 从表头开始搜索；count&lt;0 从表尾开始搜索；count=0 移出所有与value相等的元素LTRIM key start stop    截取指定key的列表中的部分元素</code></pre><h1 id="Redis集合（Set）命令"><a href="#Redis集合（Set）命令" class="headerlink" title="Redis集合（Set）命令"></a>Redis集合（Set）命令</h1><pre><code>SADD key m1 m2…    向集合添加一个或多个成员SCARD key    获取指定key对应的集合内的成员数SINTER key1 key2    获取所有给定集合的交集SISMEMBER key member    判断member元素是否是集合key的成员SMEMBERS key    返回集合中的所有成员SPOP key    返回并移出集合中的一个随机元素SREM key member1 member2    移除集合中一个或多个成员</code></pre><h1 id="Redis缓存特性"><a href="#Redis缓存特性" class="headerlink" title="Redis缓存特性"></a>Redis缓存特性</h1><pre><code>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s ，而关系型数据库MYSQL读写速度仅为2000次/s左右。丰富的数据类型 – Redis支持二进制安全的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。原子 性– Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。丰富的特性 – Redis还支持 publish/subscribe通知订阅模式, key 过期等等特性。</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpingBoot</title>
      <link href="/2024/02/23/spingboot/"/>
      <url>/2024/02/23/spingboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpingBoot"><a href="#SpingBoot" class="headerlink" title="SpingBoot"></a>SpingBoot</h1><h1 id="创建项目步骤"><a href="#创建项目步骤" class="headerlink" title="创建项目步骤"></a>创建项目步骤</h1><ul><li>创建项目步骤：(必须确保网络能正常访问)<br> 1.File-&gt;new -&gt;module<br> 2.选择spring initializr<br> 3.配置项：<pre><code> 1.group name(默认包) 2.name(发布包的名称) 3.type(maven项目） 4.packaging(打包方式，jar,war)</code></pre> 4.选择需要的依赖，选中的依赖会自动配置到pom.xml文件中，也可以手动配置<br> 5.修改pom.xml文件<pre><code> 1.修改jdk版本为本机环境对应的版本 2.修改打包方式 3.添加需要的依赖 4.配置web路径，资源路径</code></pre> 6.启动项目（找到BootdemoApplication类） </li></ul><hr><h1 id="SpingBoot整合mybatis"><a href="#SpingBoot整合mybatis" class="headerlink" title="SpingBoot整合mybatis"></a>SpingBoot整合mybatis</h1><ul><li>修改pom.xml<br>1.添加Mybatis和Mysql依赖 <!--Spring Boot Mybatis 依赖 --><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt;</code></pre>2.修改application.properties<pre><code>SpringBoot配置数据源spring.datasource.driver-class-name= com.mysql.jdbc.Driverspring.datasource.url= jdbc:mysql://192.168.0.188:3306/boot?useUnicode=truecharacterEncoding=utf8&amp;  useSSL=falsespring.datasource.username= rootspring.datasource.password= 11111111</code></pre>3.配置扫描实体类和配置扫描 映射文件        <pre><code>mybatis-plus.type-aliases-package=com.example.luo.entitymybatis-plus.mapper-locations=classpath*:/mapper/*.xml</code></pre>4.配置扫描 dao<pre><code> 只需要在 SpringBoot启动 main方法中添加注解 @MapperScan 扫描Dao 组件 //配置mybatis dao所在的包 @MapperScan("com.lgr.bootdemo1.dao") //启动类注解，包含main方法的类要添加该注解，作为程序的入口 @SpringBootApplication public class Bootdemo1Application {     public static void main(String[] args) {         SpringApplication.run(Bootdemo1Application.class, args);     } }</code></pre>5.创建数据库表<br>6.创建实体类<br> 注意:实体类路基需和第三步配置的包路径一致。<br>7.创建dao接口<br> 注意:dao接口需和第四步创建的包路径下<br>8.创建dao接口映射文件(.xml编写简便的sql语句)<br> 注意:接口映射文件必须配置在第三步配置路径下<br>9.在项目的test文件夹下项目包里有一个测试类<br> 导入实体类如：<pre><code> @Autowired BatchDAO batchDAO;</code></pre> 编写测试类,选中运行<pre><code>  @Test void contextLoads() { BatchVo batchVo = new BatchVo(); batchVo.setBatchId(0); batchVo.setBatchName("2024暑假社会实践"); batchVo.setState(1); batchVo.setRemark(""); batchDAO.insert(batchVo); }</code></pre></li></ul><hr><h1 id="SpringBoot-整合-SpringMVC"><a href="#SpringBoot-整合-SpringMVC" class="headerlink" title="SpringBoot 整合 SpringMVC"></a>SpringBoot 整合 SpringMVC</h1><pre><code>  1.在pom文件中添加  &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  -----------------------------------------------------------  spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包  此 starter pom 内嵌tomcat、servlet、SpringMVC 依赖。  启动后会默认启动tomcat 占用8080端口  没有加此依赖SpringBoot 不能启动 tomcat容器。  -----------------------------------------------------------  spring-boot-starter-web 所做的事  自动配置内嵌Servlet 容器 tomcat  自动配置http编码 utf-8  自动配置SpringMVC  自动配置文件上传(文件上传大小限制)  ------------------------------------------------------------  添加完spring-boot-starter-web 依赖 就可以使用SpringMVC的注解  @Controller 表示这是一个控制层bean  @RequestMapping  处理请求地址映射注解  @GetMapping  使用get 方式处理请求地址映射注解  @PostMapping  使用post 方式处理请求地址映射注解  @ResponseBody  设置JSON格式响应  注意：此时没有配置视图页面，只能显示html页面，不能解析JSP或者thymeleaf 等模板引擎。        添加@ResponseBody 注解可以返回JSON格式数据</code></pre><p>  SpringBoot 返回JSON数据<br>  创建IndexController(控制器)<br>  注意：IndexController 一定要创建在SpringBoot 启动main方法同级，或者下级，不然扫描不到Controller<br>  使用方法：和SpringMVC 没有区别<br>  项目启动：和普通的web项目启动不同，在SpringBoot中，启动web项目也是启动main方法，和普通的java项目没有区别！<br>  访问：<a href="http://localhost:8080/getMapJSON" target="_blank" rel="noopener">http://localhost:8080/getMapJSON</a> 得到json数据。</p><pre><code>  @GetMapping("/json")  @ResponseBody  public  Map json(){      Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();          map.put("值1","1");          map.put("值2","2");      return map;  }</code></pre><h1 id="SpringBoot-整合-JSP"><a href="#SpringBoot-整合-JSP" class="headerlink" title="SpringBoot 整合 JSP"></a>SpringBoot 整合 JSP</h1><pre><code>修改pom.xml添加依赖，修改打包信息修改application.properties 配置文件添加webapp文件夹，添加WEB-INF文件夹修改idea web项目配置修改Controller添加jsp页面</code></pre><p>1.修改pom.xml 增加依赖</p><pre><code>&lt;!-- jsp支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;  &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jstl标签库 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2.修改pom.xml修改项目打包设置</p><pre><code>      &lt;build&gt;       &lt;plugins&gt;       &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;!-- 默认版本和SpringBoot版本一致，            使用高版本的打包方式，不能正确打包。 --&gt;        &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;       &lt;/plugin&gt;       &lt;/plugins&gt;      &lt;resources&gt;      &lt;!-- 打包时将jsp文件拷贝到META-INF目录下--&gt;      &lt;resource&gt;        &lt;!-- 指定处理哪个目录下的资源文件 --&gt;        &lt;directory&gt;${basedir}/src/main/webapp&lt;/directory&gt;        &lt;!--注意此次必须要放在此目录下才能被访问到--&gt;        &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;  &lt;/resources&gt;&lt;/build&gt;</code></pre><p>3.修改application.properties 配置文件</p><pre><code>spring.mvc.view.suffix=.jspspring.mvc.view.prefix=/WEB-INF/jsp/</code></pre><p>4.添加webapp文件夹</p><pre><code>1、在src --&gt; main 下添加webapp文件夹2、在webapp下添加WEB-INF文件夹3、在WEB-INF下添加jsp文件夹4、在jsp文件夹下添加hello.jsp5、配置idea指定WEB目录</code></pre><hr><h1 id="控制器传递数据的六种方式"><a href="#控制器传递数据的六种方式" class="headerlink" title="控制器传递数据的六种方式"></a>控制器传递数据的六种方式</h1><pre><code>1.Map   @GetMapping("/map")   public String getMap(Map map){    map.put("msg1","map对象返回的值");    return "test";   }2.Model      @GetMapping("/model")public String getModel(Model model){    model.addAttribute("msg2","Model对象返回的值");    return "test";}3.ModelMap      @GetMapping("/modelMap")public String getModelMap(ModelMap model){    model.addAttribute("msg3","ModelMap对象返回的值");    return "test";}4.ModelAndView   @GetMapping("/modelAndView")public ModelAndView getModelMap(){    ModelAndView mv = new ModelAndView();    //设置返回值    mv.addObject("msg4","ModelAndView对象返回的值");    //设置页面名称    mv.setViewName("test");    return mv;}5.servlet的返回方式   @GetMapping("/request")    public String getRequest(HttpServletRequest request, HttpServletResponse response){    //设置返回值    request.setAttribute("msg5","request对象返回的值");    return "test";}6.返回JSON格式数据需要使用@ResponseBody注解@GetMapping("/json")@ResponseBodypublic BatchVo getJson(){    BatchVo batchVo = new BatchVo();    batchVo.setBatchId(0);    batchVo.setBatchName("2024暑假社会实践");    batchVo.setState(1);    batchVo.setRemark("");    return batchVo;}</code></pre><hr><h1 id="控制器接收前端数据的六种方式"><a href="#控制器接收前端数据的六种方式" class="headerlink" title="控制器接收前端数据的六种方式"></a>控制器接收前端数据的六种方式</h1><p> 方法一:</p><pre><code>  前端：      function login(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.post(           '/login/login',            {                'userName': user,                'password':pass            },            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：      //jquery的post方法提交数据      @PostMapping("/login")      @ResponseBody      public UserVo login(UserVo userVo){          System.out.println(userVo);          return userVo;      }</code></pre><p>方法二:</p><pre><code>  前端：        function login1(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login1?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：          //jquery的get方法提交数据          @GetMapping("/login1")          //login/login1?userName=张三&amp;password=1234          //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换          @ResponseBody          public UserVo login1(@RequestParam("userName") String name,@RequestParam("password") String pass){              UserVo userVo = new UserVo();              userVo.setUserName(name);              userVo.setPassword(pass);              System.out.println(userVo);              return userVo;          }</code></pre><p>方法三:</p><pre><code>  前端：      function login2(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login2?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：        //jquery的get方法提交数据        @GetMapping("/login2")        //login/login2?userName=张三&amp;password=1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login2(String userName,String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法四:</p><pre><code>  前端：     function login3(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login3/' + user + '/' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：         //jquery的get方法提交数据        @GetMapping("/login3/{userName}/{password}")        //login/login3/张三/1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login3(@PathVariable("userName") String userName,@PathVariable("password") String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法五:</p><pre><code>  前端：    function login4(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        return true;    }    控制器：            @PostMapping("/login4")      public String login4(UserVo userVo){          System.out.println(userVo);          return "index";      }        //接收表单提交数据(效果与login4一样)    @PostMapping("/login5")    public String login5(HttpServletRequest request, HttpServletResponse response){        UserVo userVo = new UserVo();        userVo.setUserName(request.getParameter("userName"));        userVo.setPassword(request.getParameter("password"));        System.out.println(userVo);        return "index";    }</code></pre><h1 id="SpringBoot整合使用druid连接池"><a href="#SpringBoot整合使用druid连接池" class="headerlink" title="SpringBoot整合使用druid连接池"></a>SpringBoot整合使用druid连接池</h1><p> 1.添加MybatisPlusConfig类</p><pre><code>   //启动事务   @EnableTransactionManagement        /*            配置文件            使用了@Configuration注解的类就是配置类，程序启动时系统会自动执行，            该注解的作用就是把以往的xml文件转换为java类            @Bean注解，就是配置一个bean，相当于mvc项目中的xml配置文件中bean        */        @Configuration        public class MybatisPlusConfig {            /**            * 分页插件,创建一个分页的拦截器            */            @Bean            public PaginationInterceptor paginationInterceptor() {                return  new PaginationInterceptor();            }        }</code></pre><p>  2.添加以下依赖</p><pre><code>&lt;!-- mysql驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.48&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis-plus --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--druid连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>  3.添加配置</p><pre><code>#所有参数的配置，冒号后面必须有一个空格        #配置tomcat的端口        server:        port: 8888        servlet:            #项目访问路径            context-path: /            #session的有效期为30分钟，m分钟，s秒            session:            timeout: 30m        #数据源配置        spring:        datasource:            driver-class-name: com.mysql.jdbc.Driver            url: jdbc:mysql://localhost:3306/boot?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true            username: root            password: 11111111            druid:            #配置监控url            stat-view-servlet:                #连接池的监控地址                url-pattern: /druid/*                #登录名                login-username: root                #登录密码                login-password: 123456                enabled: true            #初始值            initial-size: 10            #最大连接数            max-active: 100            #最小连接数            min-idle: 10            #最大等待时间            max-wait: 60000            pool-prepared-statements: true            max-pool-prepared-statement-per-connection-size: 20            time-between-eviction-runs-millis: 60000            min-evictable-idle-time-millis: 300000            #validation-query: SELECT 1 FROM DUAL            validation-query: SELECT 1 'X'            test-while-idle: true            test-on-borrow: false            test-on-return: false            filters: stat,wall,slf4j        mvc:            #配置jsp文件存放的根路径            view:            #后缀            suffix: .jsp            #前缀            prefix: /WEB-INF/jsp/        http:            #设置字符编码            encoding:            charset: UTF-8#mybatis配置(dao在启动类用@MapperScan注解配置)mybatis-plus:#mybatis的映射文件路径，放在resources的子文件夹内mapper-locations: classpath:mapper/*.xml#配置别名，javabean的包路径type-aliases-package: com.lgr.bootdemo1.entityglobal-config:    #数据库相关配置    db-config:    #主键类型  AUTO:"数据库ID自增", INPUT:"用户输入ID", ID_WORKER:"全局唯一ID (数字类型唯一ID)", UUID:"全局唯一ID UUID";    id-type: AUTO    #字段策略 IGNORED:"忽略判断",NOT_NULL:"非 NULL 判断"),NOT_EMPTY:"非空判断"    field-strategy: NOT_NULL    #驼峰下划线转换    column-underline: true    #逻辑已删除值(默认为 1)    logic-delete-value: 1    #逻辑未删除值(默认为 0)    logic-not-delete-value: 0    banner: falseconfiguration:    # 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射    map-underscore-to-camel-case: true    cache-enabled: false    call-setters-on-nulls: true    jdbc-type-for-null: 'null'    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>3.添加dao包新建BatchDAO类继承bean(extends BaseMapper<batchvo>) 添加service包下面添加impl包<br>4.service添加BatchServiceDAO类继承bean(extends IService<batchvo>)<br>5.impl包添加BatchServiceDaoImpl继承service包下面的BatchServiceDAO类(implements BatchServiceDAO )<br>6.BatchServiceDaoImpl引入dao</batchvo></batchvo></p><pre><code>@AutowiredBatchDAO batchDAO;</code></pre><p>7.右键生成方法注意添加启动事务@Transactional(查询操作外)<br>比如无条件查询表</p><pre><code>@Overridepublic List&lt;User&gt; list() {    return userDao.selectList(null);}</code></pre><p>8.添加控制器引入</p><pre><code>@Autowiredprivate UserServiceDao userServiceDao;实现方法 @RequestMapping("/list")public List&lt;User&gt; getEricUserList(){    return userServiceDao.list();}页面通过项目ip/druid/访问监控页面</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpingBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingBoot </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECharts</title>
      <link href="/2024/01/22/echarts/"/>
      <url>/2024/01/22/echarts/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ECharts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvm工具</title>
      <link href="/2024/01/22/nvm/"/>
      <url>/2024/01/22/nvm/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2024/01/22/java/"/>
      <url>/2024/01/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><ol><li>连接数据库的配置和操作</li></ol><ul><li>内存读写效率远高于磁盘读写，省去磁盘IO操作</li></ul><ol start="2"><li>存储形式</li></ol><ul><li>Redis作为K-V键值对型的内存数据库，所有键值都是用字典来存储，即哈希表结构。哈希表的特性就在O时间复杂度就可以获取对应的值。</li></ul><ol start="3"><li>编码</li></ol><ul><li>支持多种数据结构及编码，针对不通业务场景，都有相对应的数据结构和编码。</li><li>根据元素的数量，有一个阈值，小于阈值和大于阈值的编码不同。</li></ul><ol start="4"><li>IO多路复用</li></ol><ul><li>核心思想：让单个线程去监视多个连接，某个连接就绪，就触发读写事件。即可以单个线程处理多个客户端连接，无需创建和维护过多的进程和线程。</li></ul><ol start="5"><li>单线程，避免上下文切换</li></ol><ul><li>内部执行命令为单线程，避免上下文切换带来的CPU开销</li></ul><ol start="6"><li>渐进式ReHash、缓存时间戳</li></ol><ul><li>（1）渐进式ReHash：<ul><li>Redis使用全局哈希表来保存所有键值对，</li><li>哈希表相当于一个数组，数组的每个元素称为一个哈系桶，每个哈系桶中保存了键值对的数据。</li><li>数据增加到一定阈值，数组扩容会导致数据发生移动，此时访问会发生阻塞</li><li>渐进式ReHash：把一次性大量拷贝（数组移动）的开销，分摊到多次处理请求的过程中。</li><li>Redis默认使用两种全局哈希表，开始插入数据时默认使用哈希表1，此时哈希表2并没有被分配空间。随着数据逐步增多，开始执行ReHash。</li><li>给哈希表2分配更大的空间，</li></ul></li></ul><ol start="7"><li>缓存时间戳：</li></ol><ul><li>业务中需要用到时间戳时，一般会使用System.currentTimeMillis()或者New Date()等方式获取系统的毫秒时间戳，每一次获取都是一次系统调用（需要调用操作系统中对应的函数，涉及上下文切换），相对比较耗时。</li><li>作为单线程的Redis承受不起，因此它由一个定时任务，每毫秒更新一次缓存，获取时间都是从缓存中直接拿。</li></ul><h1 id="二、Redis合适的应用场景"><a href="#二、Redis合适的应用场景" class="headerlink" title="二、Redis合适的应用场景"></a>二、Redis合适的应用场景</h1><ol><li><p>常用基本数据类型（5种）<br> 名称    英文名    作用域<br> 字符串    String    缓存、计数器、分布式Session<br> 哈希    Hash    存放对象<br> 列表    list    消息队列、文章列表<br> 集合    set    标签、随机数、社交图谱<br> 有序集合    ZSET    排行榜<br> Bitmaps    Bitmaps    布隆过滤器<br> HyperLogLog    HyperLogLog    UV<br> Geo    Geo    Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作</p></li><li><p>字符串（String）</p></li></ol><ul><li><p>命令的时间复杂度：</p><ul><li><p>字符串这些命令中除了del、mset、mget支持多个键的批量操作，时间复杂度和键的个数相关，为O(n)，getrange的字符串长度相关，也是O(n)，其余的命令基本上都是O(1)的时间复杂度，在速度上还是非常快的。</p></li><li><p>（1）缓存</p><ul><li>具有支撑高并发的特性，能起到加速读写的作用，降低后端压力</li></ul></li><li><p>（2）计数器</p><ul><li>实现快速计数、查询缓存的功能，同时数据可以异步落地到其他数据源</li></ul></li><li><p>（3）分布式会话（共享Session）</p><ul><li>问题：如果一个分布式Web服务将用户的Session信息保存在各自服务器中，出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器上，用户刷新一次访问，可能会发现需要重新登录。</li></ul></li><li><p>解决方案：使用Redis将用户的Session进行集中管理，这种情况下只要保证Redis是高可用和扩展性的，每次用户更新或查询登录信息都直接从Redis集中获取。</p></li><li><p>（4）分布式锁</p></li><li><p>场景：同一个资源并发访问，如秒杀、下单减库存等场景。适用String数据类型。</p><ul><li>synchronize和reentrantlock本地锁性能较低</li><li>并发量不大，可以使用数据库悲观锁，但并发量大的场景会降抵DB性能</li><li>可以使用Redis Setnx来实现分布式锁</li></ul></li></ul></li></ul><ol start="2"><li>哈希（Hash）</li></ol><ul><li>适用于存放对象，相较于String类型存储对象时效率开发效率更高。</li></ul><ol start="3"><li>列表（list）</li></ol><ul><li>用来存储多个有序字符串<ul><li>（1）消息队列</li><li>lpush+brpop命令组合即可实现阻塞队列，生产环境客户端使用lpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的”抢“列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</li><li>（2）文章列表</li><li>每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，有序，且支持按照索引范围获取元素。</li><li>还可实现其他数据结构</li></ul></li></ul><ol start="4"><li><p>集合（set）</p><ul><li>（1）标签（tag）</li><li>例如一个用户可能对娱乐、体育感兴趣，另一个用户可能对历史、新闻感兴趣，这些兴趣点就是标签。通过这些数据可以得到喜欢同一个标签的人，这些数据对于用户体验以及增强用户粘度比较重要。</li><li>（2）随机数（抽奖活动）</li><li>（3）社交网络</li><li>点赞、粉丝、共同好友、喜好、推送、下拉刷新等功能。适用String数据类型和hash类型，存放对象使用hash类型。</li><li>标签适用于set数据类型，例如一个用户可能对娱乐、体育感兴趣，另一个用户可能对历史、新闻感兴趣，这些兴趣点就是标签。通过这些数据可以得到喜欢同一个标签的人，这些数据对于用户体验以及增强用户粘度比较重要。</li><li>排行榜适用于有序集合（ZSET）数据类型。</li></ul></li><li><p>有序集合（ZSET）</p><ul><li>（1）排行榜</li><li>多维度：时间、浏览量、获赞数等等。</li></ul></li></ol><h1 id="Redis高级数据结构"><a href="#Redis高级数据结构" class="headerlink" title="Redis高级数据结构"></a>Redis高级数据结构</h1><ol start="6"><li>Bitmaps</li></ol><ul><li>可以实现对位的操作，单独提供了一套命令，可以想象成以位为单位的数组，数组下标叫做偏移量。<ul><li>用于数据量上亿的场景下，例如几亿用户系统签到，去重登录次数统计，某用户是否在线状态等。此时不可能给每个用户一个key。</li><li>这里需要用到位操作，使用setbit、getbit、bitcount命令。</li><li>原理：redis内构一个足够长的数组，每个数组只能是0和1两个值，数组下标表示用户id，这个几亿长的大数组就可以通过下标和元素值（0和1）来构建一个记忆系统。<img width="100" src="/medias/avatars/122.png"></li><li>（1）布隆过滤器<img width="100" src="/medias/avatars/123.png"></li></ul></li></ul><ol start="7"><li>HyperLogLog </li></ol><ul><li>（1）UV</li><li>统计每个网页每天的UC数据，HyperLogLog提供不精确的去重计数方案，误差0.81%<img width="100" src="/medias/avatars/124.png"></li></ul><h1 id="三、Redis为什么6-0之前不支持多线程"><a href="#三、Redis为什么6-0之前不支持多线程" class="headerlink" title="三、Redis为什么6.0之前不支持多线程"></a>三、Redis为什么6.0之前不支持多线程</h1><ol><li>Redis的瓶颈不是CPU，受制于内存、网络</li></ol><ul><li>存储于内存，快速读写网络开销大</li></ul><ol start="2"><li>提高Redis性能，Pipeline（命令批量）</li></ol><ul><li>每秒100万个请求包装进Pipeline</li></ul><ol start="3"><li>单线程，内部维护成本相对较低，不需要管理多线程安全</li></ol><ul><li>命令执行顺序不确定性，读写并发问题</li></ul><ol start="4"><li>惰性Rehash（渐进式）减少阻塞</li></ol><ul><li>一般的公司，单线程Redis就够了。</li></ul><h1 id="四、Redis为什么6-0之后引入多线程"><a href="#四、Redis为什么6-0之后引入多线程" class="headerlink" title="四、Redis为什么6.0之后引入多线程"></a>四、Redis为什么6.0之后引入多线程</h1><ol><li><p>小数据包。数据-》内存 响应时间 100ns 8w-10wQPS（极限）</p></li><li><p>针对大的公司，需要更大的QPS，IO的多线程（内部执行命令还是单线程）</p></li><li><p>为什么不采用分布式架构—很大的缺点。</p></li></ol><ul><li><p>服务器数量多，维护成本高。Redis命令不适用需要数据分区，无法解决热点数据读写的问题。</p></li><li><p>数据倾斜、重新分配、扩容、缩容，更加复杂。</p></li><li><p>本质：多线程任务 分摊到Redis 同步IO中，读写负载。</p></li></ul><h1 id="五、Redis有哪些高级功能"><a href="#五、Redis有哪些高级功能" class="headerlink" title="五、Redis有哪些高级功能"></a>五、Redis有哪些高级功能</h1><ol><li>慢查询</li></ol><ul><li>快速定位系统中的慢操作，监测发生时间、耗时、命令的详细信息。</li></ul><ol start="2"><li><p>Pipeline</p><img width="100" src="/medias/avatars/0f3eaa5c61d04181b266ed9636af4089.png"></li><li><p>watch命令：</p></li></ol><ul><li>确保事务中的key有没有被其他客户端修改过，才执行事务，否则不执行（类似于乐观锁）。</li></ul><ol start="4"><li><p>Redis+Lua语言实现限流</p><img width="100" src="/medias/avatars/3b6961cbe30f4e1780afb7096a87a971.png"></li><li><p>分布式锁</p></li></ol><ul><li><p>首先需要Redis有互斥的能力，可以使用SETNX命令，（即如果key不存在，才会设置它的值，否则什么也不做。两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p></li><li><p>锁的过期时间不好计算</p><img width="100" src="/medias/avatars/05f7178c27cb451aadcec27cc565ed3d.png"></li><li><p>解决方案：分布式锁加入看门狗</p><ul><li>加锁时，先设置一个过期时间，然后开启<strong>“守护线程”</strong>，定时检测这个锁的失效时间，如果快要过期了，操作共享资源还未完成，则自动对锁进行续期，重新设置过期时间。</li></ul></li></ul><ol start="6"><li>高并发高可用</li></ol><ul><li>主从复制:<ul><li>提供了复制功能，实现了相同数据的多个Redis副本。每个主节点可以对应多个从节点，复制的数据流只能由主节点复制到从节点。<img width="100" src="/medias/avatars/065c62e317b64a29a9b0b9dc34111e1d.png"><img width="100" src="/medias/avatars/259f0fa00f4f4833a413835ff9c48dc6.png"></li></ul></li></ul><ol start="7"><li>哨兵：Redis Sentinel</li></ol><ul><li>背景：主从复制模式下，主节点故障，需要人工将从节点晋升为主节点。</li><li>2,8版本开始提供哨兵架构解决此问题。</li><li>主从复制的问题<ul><li>需要手动晋升子节点，同时需要修改应用方的节点地址。</li><li>主节点的写能力收到单机限制</li><li>主节点的存储能力收到单机的限制</li></ul></li></ul><h1 id="六、为什么需要使用Redis"><a href="#六、为什么需要使用Redis" class="headerlink" title="六、为什么需要使用Redis"></a>六、为什么需要使用Redis</h1><ol><li>高性能</li></ol><ul><li>Mysql（磁盘）毫秒级</li><li>Redis（内存）微秒级</li><li>更新策略：项目启动时全量同步：热点数据</li></ul><ol start="2"><li>高并发</li></ol><ul><li>Mysql 并发量：1000/s</li><li>Redis 并发量：100000/s</li><li>集群架构<img width="100" src="/medias/avatars/1300d82659ce436788cd2a3d86d4448f.png"></li></ul><h1 id="七、Redis的事务"><a href="#七、Redis的事务" class="headerlink" title="七、Redis的事务"></a>七、Redis的事务</h1><ul><li><p>本质：按照顺序串行化执行队列中的每个命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></li><li><p>顺序性、一次性、排他性执行一个队列中的一系列命令。</p><ul><li>命令    描述</li><li>EXEC    执行所有事务块命令</li><li>DISCARD    取消事务，放弃执行事务块所有命令</li><li>MULTI    标记一个事务块，开启事务</li><li>UNWATCH    取消WATCH命令对所有key的监视</li><li>WATCH    监视key，如果在事务执行之前，该key被其他命令改动，那么事务将被打断<br>  //构建redis连接<br>  Jedis jedis = jedisPool.getResource();<br>  //标记一个事务块，开启事务<br>  Transaction transaction = jedis.multi();<br>  try {<pre><code>  transaction.set("name1","江先进");</code></pre>//            int n = 10/0;<pre><code>  transaction.set("name2","张硕");  //执行事务  transaction.exec();</code></pre>  }catch (Exception e){<pre><code>  //取消事务  transaction.discard();  e.printStackTrace();</code></pre>  }</li></ul></li><li><p>回滚机制上，Redis只能对基本语法错误进行判断。运行时错误无法回滚。</p></li></ul><h1 id="八、Redis的过期策略以及内存淘汰机制"><a href="#八、Redis的过期策略以及内存淘汰机制" class="headerlink" title="八、Redis的过期策略以及内存淘汰机制"></a>八、Redis的过期策略以及内存淘汰机制</h1><ol><li>内存淘汰机制<ul><li>定期删除（定时扫描策略）</li><li>设置了过期时间的key放入独立字典，Redis默认会每秒进行十次过期扫描，不会遍历Key，而是采用简单的贪心策略。<ol><li>从过期字典中随机20个key；</li><li>删除其中已经过期的；</li><li>如果过期比例超过1/4，则重复真个步骤；</li></ol></li><li>一定要注意过期时间，如果大批量key过期（雪崩），需要给过期时间设置一个时间范围，不能全部同一时间过期<ul><li>惰性删除</li><li>客户端访问key的时候，redis对key的过期时间进行检查，如果过期就立即删除，不会返回任何东西。</li></ul></li></ul></li></ol><ul><li>总结：定期删除是集中处理，惰性删除是零散处理。</li></ul><ol start="2"><li>过期策略<ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到期清除key。该策略会立即清除过期的数据，对内存友好，但是会占用大量CPU去处理过期数据，影响吞吐量</li><li>惰性过期：只有访问一个key时，才会判断是否已过期，过期则清除。最大化节省CPU资源，对内存不友好。可能会导致大量过期的key因未被访问而无法清除。</li><li>定期过期：每隔一定时间，扫描一定数量的key，并删除其中过期的，通过调整定时扫描的时间间隔和扫描限定耗时，使CPU和内存达到一个最佳平衡状态。</li></ul></li></ol><ul><li>Redis中同时使用了惰性过期和定期过期两种策略。</li><li>每隔100ms就随机抽取一定量key，检查和删除。同时获取key时，会检查一下是否过期，过期则删除。</li><li>隐患：同样可能定期删除，漏删了大量过期key，也没有走惰性删除，就会导致大量过期key堆积在内存。</li></ul><ol start="3"><li>缓存淘汰算法</li></ol><ul><li><p>Redis 缓存淘汰算法用于在内存资源不足时，决定哪些数据需要从缓存中移除。Redis 提供了多种策略以应对不同的应用场景：</p><ol><li>volatile-lru（LRU for volatile keys）：<ul><li>当内存不足以容纳新写入的数据时，会优先剔除已设置过期时间的键值对，并根据LRU原则删除最近最少使用的数据。</li></ul></li><li>allkeys-lru：<ul><li>不区分是否设置了过期时间，所有键都会根据LRU规则淘汰，即删除最近最少使用的数据。</li></ul></li><li>volatile-ttl：<ul><li>同样针对设置了过期时间的键，但淘汰时不是基于访问频率而是基于键的剩余存活时间（TTL），选择TTL最短的键进行淘汰。</li></ul></li><li>noeviction：<ul><li>不进行任何数据淘汰，当内存满时，执行可能导致占用更多内存的命令将返回错误。</li></ul></li><li>allkeys-random：<ul><li>随机淘汰任意键，不论其是否被频繁使用或何时到期。</li></ul></li><li>volatile-random：<ul><li>淘汰一个随机的已设置过期时间的键。</li></ul></li></ol></li><li><p>值得注意的是，Redis 实现的 LRU 算法并不是精确的 LRU，因为为了性能考虑，它并没有真正维护一个完整的 LRU 链表结构。Redis 采用了一种近似 LRU 的实现方法：通过为每个键维护一个 lru 字段来记录最后一次访问的时间戳，在内存不足时，Redis 会选择一定数量（比如 5 个）的候选键，然后比较这些候选键的 lru 值，选择其中最小的一个进行淘汰。这样可以降低维护 LRU 数据结构的成本，同时在大部分情况下能够达到类似 LRU 的效果。</p></li></ul><h1 id="九、什么是缓存穿透？如何避免？"><a href="#九、什么是缓存穿透？如何避免？" class="headerlink" title="九、什么是缓存穿透？如何避免？"></a>九、什么是缓存穿透？如何避免？</h1><ul><li>本质：数据库和Redis都不存在</li><li>场景：查询id为-1的数据</li><li>坏处：每次都需要查询数据库和redis，增加磁盘IO的压力</li><li>解决方案：<ol><li>参数校验、屏蔽非法参数</li><li>数据库查询为空，可以给缓存一个空值或默认值，防止第二次再去数据库</li><li>使用布隆过滤器快速判断数据是否存在，将所有可能存在的数据哈希存到一个足够大的容器中，不存在的数据被这个bitmap拦截掉</li></ol></li><li>布隆过滤器的应用：<img width="100" src="/medias/avatars/5cc6a2b162424ca5944f5c4e90452c37.png"></li></ul><h1 id="十、什么是缓存雪崩？如何避免？"><a href="#十、什么是缓存雪崩？如何避免？" class="headerlink" title="十、什么是缓存雪崩？如何避免？"></a>十、什么是缓存雪崩？如何避免？</h1><ul><li><p>本质：数据库和Redis都存在，但redis都过期了</p></li><li><p>同一时间，缓存大面积失效，大量请求都直接去访问数据库<br>原因：</p><ol><li>Redis失效、宕机（故障）<ul><li>搭建Redis集群，主从架构</li><li>RDB持久化、IOF持久化</li><li>加入缓存组件：EHCache，搭建多级缓存（容易高并发的数据存入）</li><li>加入限流组件：hystrix，超过一定流量后，增加请求限制（保护数据处理层）</li></ul></li><li>Redis大量key的ttl过期<ul><li>ttl（过期时间）岔开，增加随机值，避免同一时间全部失效。<img width="100" src="/medias/avatars/fe44ca85df454d55939e774acd2cadb2.png"></li></ul></li></ol></li><li><p>解决方案：</p><ul><li>热点数据永不过期，或者通过异步线程在每次热点数据快要过期时，进行续期</li><li>数据的过期时间不要全一致，设为一定范围内的随机时间</li><li>并发量不高，可加入队列或者锁，限制同一时间访问数据库的阈值</li><li>分布式部署，将热点数据打散分不到多个节点</li><li>如果是缓存中间件宕机了，需要尽可能保证其高可用性，可以搭建redis集群，提前做好报警机制</li></ul></li></ul><h1 id="十一、缓存击穿"><a href="#十一、缓存击穿" class="headerlink" title="十一、缓存击穿"></a>十一、缓存击穿</h1><ul><li>本质：单个key没有或过期，同一时间查询这同一条数据并发量过多</li><li>解决方案：<ol><li>热点数据用不过期，或者通过异步线程在每次热点数据快要过期时，进行续期</li><li>使用互斥锁，避免大量请求同时查询数据库</li><li>熔断、降级、防止系统崩溃</li><li>还可以考虑对重要的热点数据进行多级缓存</li></ol></li></ul><h1 id="十二、Redis如何设计分布式锁"><a href="#十二、Redis如何设计分布式锁" class="headerlink" title="十二、Redis如何设计分布式锁"></a>十二、Redis如何设计分布式锁</h1><ul><li>概念：<ul><li>锁：同一时间只允许一个线程或者一个应用程序进入执行</li><li>分布式锁：必须要求Redis有【互斥】能力，可以使用SETNX命令：即key不存在了才会设置它的值，否则什么也不做。</li></ul></li><li>注意事项：<ol><li>如果过期时间是每个服务自己生成，需要保证每个客户端时间同步。</li><li>必须保存持有者唯一标识，否则可能被别的客户端释放/解锁。</li><li>给锁设置过期时间，以免进程挂了或异常了无法释放锁。</li><li>加入看门狗：开启守护线程，定期检测锁的失效时间，如果快过期了，业务还没有执行完，则续期。</li></ol></li><li>看门狗：开源框架Redisson，只要线程一个线程加锁成功，就会启动一个watch dog，每隔10秒检查一下锁是否释放，只要第一个线程还持有锁，就延长锁的失效时间，解决了锁过期但业务还没执行完的问题。</li></ul><h1 id="十三、什么是bigkey？会有什么影响？"><a href="#十三、什么是bigkey？会有什么影响？" class="headerlink" title="十三、什么是bigkey？会有什么影响？"></a>十三、什么是bigkey？会有什么影响？</h1><ol><li>概念：</li></ol><ul><li>key对应的value所占内存空间较大</li><li>例如一个字符串类型的value最大存到512M，一个列表类型的value最大可以存储2的32次方-1个元素。</li></ul><ol start="2"><li>字符串类型：</li></ol><ul><li>体现在单个value值特别大，一般认为超过10kb就是bigkey，和具体OPS相关（不同系统不同并发）。</li></ul><ol start="3"><li>非字符串类型：</li></ol><ul><li>哈希、列表、集合、有序集合，体现在元素个数过多。</li></ul><ol start="4"><li><p>危害：</p><ul><li>内存空间不均匀</li><li>超时堵塞：单线程操作bigkey比较耗时</li><li>网络拥塞：每次获取bigkey产生的网络流量较大</li><li>例如：一个bigkey为1MB，每秒访问为1000，则每秒产生1000MB的流量，普通千兆网（按照字节算是128MB/s）的服务器是灭顶之灾，而且服务器通常会采用单机多实例的方式来部署，可能会对其他实例造成影响。</li></ul></li><li><p>解决方案：value拆分</p></li></ol><h1 id="十四、Redis如何解决key冲突"><a href="#十四、Redis如何解决key冲突" class="headerlink" title="十四、Redis如何解决key冲突"></a>十四、Redis如何解决key冲突</h1><ol><li>业务隔离</li><li>key的设计</li></ol><ul><li>业务模块+系统名称+关键（id），针对用户可以加入（userid）</li></ul><ol start="3"><li>分布式锁</li></ol><ul><li>场景：多个客户端并发写key</li><li>客户端拿到锁，才能进行操作，避免多个客户端竞争该key</li></ul><ol start="4"><li>时间戳</li></ol><ul><li>key拼接时间戳，根据时间戳保证多个客户端的业务执行顺序</li></ul><h1 id="十五、怎么提高换成命中率"><a href="#十五、怎么提高换成命中率" class="headerlink" title="十五、怎么提高换成命中率"></a>十五、怎么提高换成命中率</h1><ol><li>提前加载</li><li>增加缓存的存储空间，增加缓存的数据</li><li>调整缓存的存储类型</li></ol><ul><li>例：对象通过Hash存储，而不用String。</li><li>根据业务做适当调整。</li></ul><ol start="4"><li>调整缓存的存储类型<ul><li>定时任务更新</li><li>MySQL通过检测binlog，将消息推送到Redis，更新缓存</li><li>通过Mq，业务更新修改数据时，通过MQ发送消息，消费更新缓存</li></ul></li></ol><h1 id="十六、Redis持久化方式有哪些方式？有什么区别？"><a href="#十六、Redis持久化方式有哪些方式？有什么区别？" class="headerlink" title="十六、Redis持久化方式有哪些方式？有什么区别？"></a>十六、Redis持久化方式有哪些方式？有什么区别？</h1><ol><li>持久化</li></ol><ul><li>将数据写入磁盘，避免因进程退出而造成的数据丢失，下次重启时通过持久化文件恢复数据。</li></ul><ol start="2"><li>RDB</li></ol><ul><li>通过快照（内存中数据在某一时刻的状态记录）的方式实现持久化，根据快照的触发条件，将内存的数据快照写入磁盘，以二进制的压缩文件进行存储。</li><li>缺点：每隔一段时间触发持久化，数据安全性低。</li></ul><ol start="3"><li>AOF</li></ol><ul><li>以独立日志的方式记录每次写的命令，重启时重新执行AOF文件中的命令恢复数据</li><li>AOF重写机制：AOF文件的大小达到某个阈值时，会将其中指令进行压缩。(如果有对于某个key多次的变更指令，则仅保留最新的数据指令)。</li><li>优化：<ul><li>因为AOF重写过程中需要读取当前内存中所有键值数据，性能较低，redis将其放在一个后台子线程中完成。</li><li>为了避免重写过程中出现数据变动，主进程的数据变更需要追加到AOF重写缓冲区中，等到AOF重写完成后，再把AOF重写换乘区里面的内容追加到新的AOF文件中。</li></ul></li><li>缺点：AOF文件可能过大，性能较差</li></ul><ol start="4"><li>混合式</li></ol><ul><li>如果执行bgrewriteaof命令，将内存中已有的数据以二进制格式存放在AOF文件中（模拟RDB），后续命令亦然采用AOF追加方式。</li><li>生产环境中一般采用两种持久化机制混合使用。</li><li>将内存中数据快照存储在AOF文件中（模拟RDB），后续再以AOF追加方式。</li><li>如果仅作为缓存使用，可以承受几分钟数据丢失，可以使用RDB，对主程序性能影响最小。<img width="100" src="/medias/avatars/d4ae5638b33c4a00ba7dc215d62d9f6a.png"></li></ul><h1 id="十七、为什么Redis需要把所有数据放到内存中？"><a href="#十七、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="十七、为什么Redis需要把所有数据放到内存中？"></a>十七、为什么Redis需要把所有数据放到内存中？</h1><ol><li><p>内存访问与磁盘访问的差距：</p><img width="100" src="/medias/avatars/fa449af16b4d41b0898eaa3e68b85f11.png"><ul><li>几乎是10倍以上，如果不是顺序读取而是随机读取效率会相差更大</li><li>同时还有CPU上下文切换的开销</li></ul></li><li><p>Redis通过异步，持久化将数据写入磁盘</p></li><li><p>随着技术的发展，硬件上来说内存也越来越便宜了</p></li><li><p>默认情况下，哪怕Redis内存不够了，也不会发生宕机，而是只可读不能写（Noeviction策略）</p></li><li><p>通过内存淘汰策略，确保整体服务正常运行</p></li></ol><h1 id="十八、如何保证缓存与数据库双写一致性？"><a href="#十八、如何保证缓存与数据库双写一致性？" class="headerlink" title="十八、如何保证缓存与数据库双写一致性？"></a>十八、如何保证缓存与数据库双写一致性？</h1><ol><li>新增数据类</li></ol><ul><li>新增数据时，数据会直接写入数据库，不用对缓存做任何操作；此时缓存没有新增数据，而数据库中最新值。</li></ul><ol start="2"><li>更新缓存类</li></ol><ul><li>（1）先更新缓存，在更新DB（一般不考虑）</li><li>原因：缓存更新成功，更新数据库时出现异常，会导致数据源与缓存数据完全不一致，而且很难察觉，因为缓存中的数据一直都存在。</li><li>（2）先更新DB，在更新缓存（一般不考虑）</li><li>原因：数据库更新成功了，缓存更新失败了，同样会导致数据源与缓存数据完全不一致，也很难察觉。</li></ul><ol start="3"><li>删除缓存</li></ol><ul><li>（3）先删除缓存，后更新DB</li><li>问题：</li><li>两个请求：A（更新）和B（查询）</li><li>A -&gt; 删除缓存中的数据 -&gt; 更新数据库</li><li>B -&gt; 查询缓存为空 -&gt; 查询数据库 -&gt; 补录到缓存</li><li>A -&gt; 还未更新成功/事务还未提交，B -&gt; 查询到的其实是数据库旧值</li><li>A -&gt; 还未更新成功/事务还未提交，B -&gt; 查询到的其实是数据库旧值</li><li>解决方案：</li><li>先淘汰缓存</li><li>再写数据库</li><li>休眠1秒，再次淘汰缓存</li><li>这个休眠的时间需要评估项目的读数据业务逻辑的耗时，确保请求结束时，写请求可以删除读请求造成的缓存脏数据。</li><li>（4）先更新DB，后删除缓存</li><li>查询：先读缓存 -&gt; 缓存没有就读数据库 -&gt; 取出数据放入缓存 -&gt; 同时返回响应。</li><li>更新：先更新数据库 -&gt; 删除缓存</li></ul><ol start="4"><li>如何选择</li></ol><ul><li><p>一般线上更多偏向于删除缓存类操作（容易避免问题）</p></li><li><p>原因：</p><ul><li>删除缓存比在DB中要快，所以一般先更新DB，后删除缓存</li><li>问题只会出现在查询比删除慢的情况，出现率相对最少</li><li>同时延迟双删可以有效避免缓存不一致情况。<img width="100" src="/medias/avatars/7190a8f437a1490eb13f3892b448d796.png"></li></ul></li><li><p>伪代码实现延迟双删：<br> redis.deykey(X)<br> db.update(X)<br> Thread.sleep(N)<br> redis.delKey(X)</p></li></ul><ol start="5"><li>读取binlog日志</li></ol><ul><li>异步删除、更新缓存，<ul><li>可以使用canal将binlog日志采集发送到MQ队列中。</li><li>通过ACK机制确认处理这条更新消息，删除缓存，保证数据一致性。<h1 id="十九、Redis集群方案"><a href="#十九、Redis集群方案" class="headerlink" title="十九、Redis集群方案"></a>十九、Redis集群方案</h1></li></ul></li><li>分布式解决方案 ：Redis Cluster</li><li>3.0版本推出</li><li>场景：单机内存、并发、流量等瓶颈</li><li>方案：</li><li>（1）客户端分区：</li><li>优点：分区逻辑可控</li><li>缺点：需要处理数据路由、高可用、故障转移等问题</li><li>（2）代理方案：</li><li>优点：简化客户端分布式逻辑，升级维护便利</li><li>缺点：加重架构部署复杂度和性能损耗</li></ul><ol start="2"><li>虚拟槽分区（0~16383）<img width="100" src="/medias/avatars/4a17080d64d1485f9f793488948b07e8.png"></li></ol><ul><li>主节点数量基本不可能超过1000个，节点连接需要不断发送ping/pong命令，消耗网络带宽</li></ul><ol start="3"><li>集群功能限制</li></ol><ul><li>（1）key批量操作支持有限：mset、mget仅支持相同slot值的key。</li><li>（2）key事务操作支持有限：仅支持在同一节点上的事务操作。</li><li>（3）key作为数据分区的最小颗粒度，不允许大的键值对（hash、list）映射在不同节点。</li><li>（4）不支持多数据库空间。单机为0-15（16个），集群模式仅能使用db0。</li><li>（5）复制结构仅支持一层，节点只能复制到主节点，不支持嵌套树状复制结构。</li></ul><ol start="4"><li>搭建集群</li></ol><ul><li>方式:</li><li>（1）Redis协议手工搭建。</li><li>（2）5.0之前有ruby语言脚本搭建。</li><li>（3）5.0之后搭建功能合并至redis-cli。</li><li>节点数至少奇数点个，官方推荐三主三从。</li></ul><h1 id="二十、Redis集群方案什么情况下会导致整个集群不可用？"><a href="#二十、Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="二十、Redis集群方案什么情况下会导致整个集群不可用？"></a>二十、Redis集群方案什么情况下会导致整个集群不可用？</h1><ul><li>A、B、C三个节点集群，B节点失败（主故障，且没有替代方案）整个集群都是不可用的。</li><li>集群不可用判定：</li><li>保护措施：默认情况下当16384个槽点任何一个没有指派到节点时，整个集群不可用。</li><li>主节点下线-&gt;故障发现-&gt;自动完成转移期间，整个集群为不可用状态。</li><li>可用通过设置cluster-require-full-coverage配置为no：主节点故障时，不影响其他主节点的可用性。</li></ul><h1 id="二十一、Redis集群会有写操作丢失吗？为什么？"><a href="#二十一、Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="二十一、Redis集群会有写操作丢失吗？为什么？"></a>二十一、Redis集群会有写操作丢失吗？为什么？</h1><ul><li>Redis无法保证数据的强一致性</li><li>一般只能向主节点写入数据，再异步同步到子节点</li><li>此时如果响应给客户端后还未异步同步成功时，主节点宕机了，子节点升至主节点，此时就会出现写入操作丢失。</li></ul><h1 id="二十二、Redis常见性能问题和解决方案"><a href="#二十二、Redis常见性能问题和解决方案" class="headerlink" title="二十二、Redis常见性能问题和解决方案"></a>二十二、Redis常见性能问题和解决方案</h1><ol><li>持久化 性能问题</li></ol><ul><li>早期仅支持全量复制-&gt;部分复制（一台机器性能开销过大）</li><li>因此开始配置主从 ：主节点不再做持久化而是交给从节点来做</li></ul><ol start="2"><li>数据比较重要，开启AOF。策略最好配置每秒同步。</li><li>主从复制 流畅，建议同一个局域网内操作，负责网络开销过大</li><li>尽量避免主库压力过大，增加从库</li><li>主从复制 尽量不要使用网状结构、线性结构</li></ol><h1 id="二十三、热点数据和冷数据"><a href="#二十三、热点数据和冷数据" class="headerlink" title="二十三、热点数据和冷数据"></a>二十三、热点数据和冷数据</h1><ol><li>热数据</li></ol><ul><li>访问频次较高，考虑使用缓存Redis</li><li>地图信息</li><li>点赞数、收藏数、分享数（不断变化）同步Redis</li><li>数据更新之前至少读取2次才能放缓存</li></ul><ol start="2"><li>冷数据</li></ol><ul><li>访问频次少</li><li>不需要放缓存</li></ul><h1 id="二十四、什么情况下可能会导致Redis阻塞"><a href="#二十四、什么情况下可能会导致Redis阻塞" class="headerlink" title="二十四、什么情况下可能会导致Redis阻塞"></a>二十四、什么情况下可能会导致Redis阻塞</h1><ol><li>客户端阻塞</li></ol><ul><li>命令执行时间过长： keys* Hgetall smembers 时间复杂度O(N)</li></ul><ol start="2"><li>BIGkey删除</li></ol><ul><li>需要释放大量占用内存 zset（100万的元素 删除大概需要2s）</li></ul><ol start="3"><li>清空库</li></ol><ul><li>flushdb flushall 涉及删除所有键值对</li></ul><ol start="4"><li>AOF日志同步写，记录AOF日志</li></ol><ul><li>大量写的操作</li><li>一个同步写磁盘操作大概耗时1~2ms</li></ul><ol start="5"><li>从库 加载RDB文件</li></ol><ul><li>RDB文件过大</li></ul><ol start="6"><li>Redis尽量部署在独立的服务器中</li></ol><ul><li>二十五、线上Redis响应慢处理思路<ol><li>紧急处理方案，扩容</li><li>生产环境查看Redis内存使用率，分析一定时间段内key数量变化</li></ol><ul><li>分析是否是大量数据未设置过期时间，或者是因为新版本迭代引起</li></ul><ol start="3"><li>清除bigkey，优化生成bigkey的代码块，调整未设置过期时间的代码块</li><li>根据业务场景调整淘汰策略</li></ol></li></ul><h1 id="二十六、-Redis-高可用"><a href="#二十六、-Redis-高可用" class="headerlink" title="二十六、 Redis 高可用"></a>二十六、 Redis 高可用</h1><ul><li>高可用：数据不能丢失（尽量减少丢失），保证Redis</li><li>26.1 主从模式</li><li>部署多台Redis服务器，主从复制以保证数据副本一致。主库通过将RDB文件发送给从库实现复制。</li><li>主从之间采用读写分离，主库写操作，从库仅负责读操作。</li><li>主库如果宕机了，人工切换一台从库称为主库，通知应用方更新主节点地址。</li><li>问题：数据不一致。</li><li>原因：主从库网络延迟，从库接收到命令，但它正在执行阻塞性命令。</li><li>解决方法：保证网络通畅，监控主从库复制进度。</li><li>26.2 哨兵模式</li><li>Redis从2.8开始提供哨兵机制。</li><li>####26.2.1 作用</li><li>监控：周期性ping主从库，检测是否挂了，标记下线状态。</li><li>自动选主切换：多个从库中按照一定规则选一个作为主库。</li><li>通知：选出主库后，将新主库的连接信息发送给其他从库以及应用方，重新建立联系。</li><li>26.2.2 哨兵</li><li>由一个或多个哨兵实例组成哨兵系统，监控其他Redis节点的同时，哨兵实例之间也互相监控。</li><li>哨兵之间通过发布订阅机制组成集群。一主多从</li><li>缺点：无法实现在线扩容，并发压力受限于单个服务器的资源配置。</li><li>26.3 Redis Cluster</li><li>哨兵模式解决了自动切换主从的问题，但是没有解决在线扩容的问题。</li><li>本质：Redis Cluster实现了Redis的分布式存储，每个节点存储不同的数据，实现数据分片。</li><li>引入Slot槽实现数据分片，每个节点分配一个Slot区间，当我们存取Key的时候，Redis根据key计算得到Slot值，找到对应的节点进行读写。多主多从。</li></ul><h1 id="二十七、布隆过滤器"><a href="#二十七、布隆过滤器" class="headerlink" title="二十七、布隆过滤器"></a>二十七、布隆过滤器</h1><ul><li>布隆过滤器可以应对缓存穿透问题</li><li>数据结构：一个很长的二进制向量和一组Hash映射函数组成。</li><li>作用：检索一个元素是否在一个集合中，空间查询效率比一般的算法要好的多。</li><li>缺点：有一定误识别率和删除困难。</li><li>原理：集合A中有n个元素，利用K个哈希散列函数，将A中每个元素映射到一个长度为a位的数组B中不同位置上。这些位置上的二进制数均设置为1。经过这个K个哈希散列函数映射后，发现其k个位置上的二进制数全部为1，这个元素很可能属于集合A。</li></ul><h1 id="二十八、Redis的理解"><a href="#二十八、Redis的理解" class="headerlink" title="二十八、Redis的理解"></a>二十八、Redis的理解</h1><ul><li>本质：基于Key-Value存储结构的非关系型数据库</li><li>数据类型：提供5种基本数据类型，String、set、zset、list、Map。</li><li>性能：基于内存存储，并且在数据结构上做了大量优化，IO性能较好。</li><li>作用：作为应用与数据库之间的分布式缓存组件。</li><li>高可用：提供了主从复制、哨兵、以及集群方式实现高可用，集群中通过hash槽的方式实现了数据分片，进一步提升了性能</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="/2024/01/22/redis-mian-shi-ti/"/>
      <url>/2024/01/22/redis-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h1><h3 id="一、Redis为什么快？"><a href="#一、Redis为什么快？" class="headerlink" title="一、Redis为什么快？"></a>一、Redis为什么快？</h3><ol><li>基于内存</li></ol><ul><li>内存读写效率远高于磁盘读写，省去磁盘IO操作</li></ul><ol start="2"><li>存储形式</li></ol><ul><li>Redis作为K-V键值对型的内存数据库，所有键值都是用字典来存储，即哈希表结构。哈希表的特性就在O时间复杂度就可以获取对应的值。</li></ul><ol start="3"><li>编码</li></ol><ul><li>支持多种数据结构及编码，针对不通业务场景，都有相对应的数据结构和编码。</li><li>根据元素的数量，有一个阈值，小于阈值和大于阈值的编码不同。</li></ul><ol start="4"><li>IO多路复用</li></ol><ul><li>核心思想：让单个线程去监视多个连接，某个连接就绪，就触发读写事件。即可以单个线程处理多个客户端连接，无需创建和维护过多的进程和线程。</li></ul><ol start="5"><li>单线程，避免上下文切换</li></ol><ul><li>内部执行命令为单线程，避免上下文切换带来的CPU开销</li></ul><ol start="6"><li>渐进式ReHash、缓存时间戳</li></ol><ul><li>（1）渐进式ReHash：<ul><li>Redis使用全局哈希表来保存所有键值对，</li><li>哈希表相当于一个数组，数组的每个元素称为一个哈系桶，每个哈系桶中保存了键值对的数据。</li><li>数据增加到一定阈值，数组扩容会导致数据发生移动，此时访问会发生阻塞</li><li>渐进式ReHash：把一次性大量拷贝（数组移动）的开销，分摊到多次处理请求的过程中。</li><li>Redis默认使用两种全局哈希表，开始插入数据时默认使用哈希表1，此时哈希表2并没有被分配空间。随着数据逐步增多，开始执行ReHash。</li><li>给哈希表2分配更大的空间，</li></ul></li></ul><ol start="7"><li>缓存时间戳：</li></ol><ul><li>业务中需要用到时间戳时，一般会使用System.currentTimeMillis()或者New Date()等方式获取系统的毫秒时间戳，每一次获取都是一次系统调用（需要调用操作系统中对应的函数，涉及上下文切换），相对比较耗时。</li><li>作为单线程的Redis承受不起，因此它由一个定时任务，每毫秒更新一次缓存，获取时间都是从缓存中直接拿。</li></ul><h3 id="二、Redis合适的应用场景"><a href="#二、Redis合适的应用场景" class="headerlink" title="二、Redis合适的应用场景"></a>二、Redis合适的应用场景</h3><ol><li><p>常用基本数据类型（5种）<br> 名称    英文名    作用域<br> 字符串    String    缓存、计数器、分布式Session<br> 哈希    Hash    存放对象<br> 列表    list    消息队列、文章列表<br> 集合    set    标签、随机数、社交图谱<br> 有序集合    ZSET    排行榜<br> Bitmaps    Bitmaps    布隆过滤器<br> HyperLogLog    HyperLogLog    UV<br> Geo    Geo    Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作</p></li><li><p>字符串（String）</p></li></ol><ul><li><p>命令的时间复杂度：</p><ul><li><p>字符串这些命令中除了del、mset、mget支持多个键的批量操作，时间复杂度和键的个数相关，为O(n)，getrange的字符串长度相关，也是O(n)，其余的命令基本上都是O(1)的时间复杂度，在速度上还是非常快的。</p></li><li><p>（1）缓存</p><ul><li>具有支撑高并发的特性，能起到加速读写的作用，降低后端压力</li></ul></li><li><p>（2）计数器</p><ul><li>实现快速计数、查询缓存的功能，同时数据可以异步落地到其他数据源</li></ul></li><li><p>（3）分布式会话（共享Session）</p><ul><li>问题：如果一个分布式Web服务将用户的Session信息保存在各自服务器中，出于负载均衡的考虑，分布式服务会将用户的访问均衡到不同服务器上，用户刷新一次访问，可能会发现需要重新登录。</li></ul></li><li><p>解决方案：使用Redis将用户的Session进行集中管理，这种情况下只要保证Redis是高可用和扩展性的，每次用户更新或查询登录信息都直接从Redis集中获取。</p></li><li><p>（4）分布式锁</p></li><li><p>场景：同一个资源并发访问，如秒杀、下单减库存等场景。适用String数据类型。</p><ul><li>synchronize和reentrantlock本地锁性能较低</li><li>并发量不大，可以使用数据库悲观锁，但并发量大的场景会降抵DB性能</li><li>可以使用Redis Setnx来实现分布式锁</li></ul></li></ul></li></ul><ol start="2"><li>哈希（Hash）</li></ol><ul><li>适用于存放对象，相较于String类型存储对象时效率开发效率更高。</li></ul><ol start="3"><li>列表（list）</li></ol><ul><li>用来存储多个有序字符串<ul><li>（1）消息队列</li><li>lpush+brpop命令组合即可实现阻塞队列，生产环境客户端使用lpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的”抢“列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</li><li>（2）文章列表</li><li>每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，有序，且支持按照索引范围获取元素。</li><li>还可实现其他数据结构</li></ul></li></ul><ol start="4"><li><p>集合（set）</p><ul><li>（1）标签（tag）</li><li>例如一个用户可能对娱乐、体育感兴趣，另一个用户可能对历史、新闻感兴趣，这些兴趣点就是标签。通过这些数据可以得到喜欢同一个标签的人，这些数据对于用户体验以及增强用户粘度比较重要。</li><li>（2）随机数（抽奖活动）</li><li>（3）社交网络</li><li>点赞、粉丝、共同好友、喜好、推送、下拉刷新等功能。适用String数据类型和hash类型，存放对象使用hash类型。</li><li>标签适用于set数据类型，例如一个用户可能对娱乐、体育感兴趣，另一个用户可能对历史、新闻感兴趣，这些兴趣点就是标签。通过这些数据可以得到喜欢同一个标签的人，这些数据对于用户体验以及增强用户粘度比较重要。</li><li>排行榜适用于有序集合（ZSET）数据类型。</li></ul></li><li><p>有序集合（ZSET）</p><ul><li>（1）排行榜</li><li>多维度：时间、浏览量、获赞数等等。</li></ul></li></ol><h3 id="Redis高级数据结构"><a href="#Redis高级数据结构" class="headerlink" title="Redis高级数据结构"></a>Redis高级数据结构</h3><ol start="6"><li>Bitmaps</li></ol><ul><li>可以实现对位的操作，单独提供了一套命令，可以想象成以位为单位的数组，数组下标叫做偏移量。<ul><li>用于数据量上亿的场景下，例如几亿用户系统签到，去重登录次数统计，某用户是否在线状态等。此时不可能给每个用户一个key。</li><li>这里需要用到位操作，使用setbit、getbit、bitcount命令。</li><li>原理：redis内构一个足够长的数组，每个数组只能是0和1两个值，数组下标表示用户id，这个几亿长的大数组就可以通过下标和元素值（0和1）来构建一个记忆系统。<img width="100" src="/medias/avatars/122.png"></li><li>（1）布隆过滤器<img width="100" src="/medias/avatars/123.png"></li></ul></li></ul><ol start="7"><li>HyperLogLog </li></ol><ul><li>（1）UV</li><li>统计每个网页每天的UC数据，HyperLogLog提供不精确的去重计数方案，误差0.81%<img width="100" src="/medias/avatars/124.png"></li></ul><h3 id="三、Redis为什么6-0之前不支持多线程"><a href="#三、Redis为什么6-0之前不支持多线程" class="headerlink" title="三、Redis为什么6.0之前不支持多线程"></a>三、Redis为什么6.0之前不支持多线程</h3><ol><li>Redis的瓶颈不是CPU，受制于内存、网络</li></ol><ul><li>存储于内存，快速读写网络开销大</li></ul><ol start="2"><li>提高Redis性能，Pipeline（命令批量）</li></ol><ul><li>每秒100万个请求包装进Pipeline</li></ul><ol start="3"><li>单线程，内部维护成本相对较低，不需要管理多线程安全</li></ol><ul><li>命令执行顺序不确定性，读写并发问题</li></ul><ol start="4"><li>惰性Rehash（渐进式）减少阻塞</li></ol><ul><li>一般的公司，单线程Redis就够了。</li></ul><h3 id="四、Redis为什么6-0之后引入多线程"><a href="#四、Redis为什么6-0之后引入多线程" class="headerlink" title="四、Redis为什么6.0之后引入多线程"></a>四、Redis为什么6.0之后引入多线程</h3><ol><li><p>小数据包。数据-》内存 响应时间 100ns 8w-10wQPS（极限）</p></li><li><p>针对大的公司，需要更大的QPS，IO的多线程（内部执行命令还是单线程）</p></li><li><p>为什么不采用分布式架构—很大的缺点。</p></li></ol><ul><li><p>服务器数量多，维护成本高。Redis命令不适用需要数据分区，无法解决热点数据读写的问题。</p></li><li><p>数据倾斜、重新分配、扩容、缩容，更加复杂。</p></li><li><p>本质：多线程任务 分摊到Redis 同步IO中，读写负载。</p></li></ul><h3 id="五、Redis有哪些高级功能"><a href="#五、Redis有哪些高级功能" class="headerlink" title="五、Redis有哪些高级功能"></a>五、Redis有哪些高级功能</h3><ol><li>慢查询</li></ol><ul><li>快速定位系统中的慢操作，监测发生时间、耗时、命令的详细信息。</li></ul><ol start="2"><li><p>Pipeline</p><img width="100" src="/medias/avatars/0f3eaa5c61d04181b266ed9636af4089.png"></li><li><p>watch命令：</p></li></ol><ul><li>确保事务中的key有没有被其他客户端修改过，才执行事务，否则不执行（类似于乐观锁）。</li></ul><ol start="4"><li><p>Redis+Lua语言实现限流</p><img width="100" src="/medias/avatars/3b6961cbe30f4e1780afb7096a87a971.png"></li><li><p>分布式锁</p></li></ol><ul><li><p>首先需要Redis有互斥的能力，可以使用SETNX命令，（即如果key不存在，才会设置它的值，否则什么也不做。两个客户端进程可以执行这个命令，达到互斥，就可以实现一个分布式锁。</p></li><li><p>锁的过期时间不好计算</p><img width="100" src="/medias/avatars/05f7178c27cb451aadcec27cc565ed3d.png"></li><li><p>解决方案：分布式锁加入看门狗</p><ul><li>加锁时，先设置一个过期时间，然后开启<strong>“守护线程”</strong>，定时检测这个锁的失效时间，如果快要过期了，操作共享资源还未完成，则自动对锁进行续期，重新设置过期时间。</li></ul></li></ul><ol start="6"><li>高并发高可用</li></ol><ul><li>主从复制:<ul><li>提供了复制功能，实现了相同数据的多个Redis副本。每个主节点可以对应多个从节点，复制的数据流只能由主节点复制到从节点。<img width="100" src="/medias/avatars/065c62e317b64a29a9b0b9dc34111e1d.png"><img width="100" src="/medias/avatars/259f0fa00f4f4833a413835ff9c48dc6.png"></li></ul></li></ul><ol start="7"><li>哨兵：Redis Sentinel</li></ol><ul><li>背景：主从复制模式下，主节点故障，需要人工将从节点晋升为主节点。</li><li>2,8版本开始提供哨兵架构解决此问题。</li><li>主从复制的问题<ul><li>需要手动晋升子节点，同时需要修改应用方的节点地址。</li><li>主节点的写能力收到单机限制</li><li>主节点的存储能力收到单机的限制</li></ul></li></ul><h3 id="六、为什么需要使用Redis"><a href="#六、为什么需要使用Redis" class="headerlink" title="六、为什么需要使用Redis"></a>六、为什么需要使用Redis</h3><ol><li>高性能</li></ol><ul><li>Mysql（磁盘）毫秒级</li><li>Redis（内存）微秒级</li><li>更新策略：项目启动时全量同步：热点数据</li></ul><ol start="2"><li>高并发</li></ol><ul><li>Mysql 并发量：1000/s</li><li>Redis 并发量：100000/s</li><li>集群架构<img width="100" src="/medias/avatars/1300d82659ce436788cd2a3d86d4448f.png"></li></ul><h3 id="七、Redis的事务"><a href="#七、Redis的事务" class="headerlink" title="七、Redis的事务"></a>七、Redis的事务</h3><ul><li><p>本质：按照顺序串行化执行队列中的每个命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></li><li><p>顺序性、一次性、排他性执行一个队列中的一系列命令。</p><ul><li>命令    描述</li><li>EXEC    执行所有事务块命令</li><li>DISCARD    取消事务，放弃执行事务块所有命令</li><li>MULTI    标记一个事务块，开启事务</li><li>UNWATCH    取消WATCH命令对所有key的监视</li><li>WATCH    监视key，如果在事务执行之前，该key被其他命令改动，那么事务将被打断<br>  //构建redis连接<br>  Jedis jedis = jedisPool.getResource();<br>  //标记一个事务块，开启事务<br>  Transaction transaction = jedis.multi();<br>  try {<pre><code>  transaction.set("name1","江先进");</code></pre>//            int n = 10/0;<pre><code>  transaction.set("name2","张硕");  //执行事务  transaction.exec();</code></pre>  }catch (Exception e){<pre><code>  //取消事务  transaction.discard();  e.printStackTrace();</code></pre>  }</li></ul></li><li><p>回滚机制上，Redis只能对基本语法错误进行判断。运行时错误无法回滚。</p></li></ul><h3 id="八、Redis的过期策略以及内存淘汰机制"><a href="#八、Redis的过期策略以及内存淘汰机制" class="headerlink" title="八、Redis的过期策略以及内存淘汰机制"></a>八、Redis的过期策略以及内存淘汰机制</h3><ol><li>内存淘汰机制<ul><li>定期删除（定时扫描策略）</li><li>设置了过期时间的key放入独立字典，Redis默认会每秒进行十次过期扫描，不会遍历Key，而是采用简单的贪心策略。<ol><li>从过期字典中随机20个key；</li><li>删除其中已经过期的；</li><li>如果过期比例超过1/4，则重复真个步骤；</li></ol></li><li>一定要注意过期时间，如果大批量key过期（雪崩），需要给过期时间设置一个时间范围，不能全部同一时间过期<ul><li>惰性删除</li><li>客户端访问key的时候，redis对key的过期时间进行检查，如果过期就立即删除，不会返回任何东西。</li></ul></li></ul></li></ol><ul><li>总结：定期删除是集中处理，惰性删除是零散处理。</li></ul><ol start="2"><li>过期策略<ul><li>定时过期：每个设置过期时间的key都需要创建一个定时器，到期清除key。该策略会立即清除过期的数据，对内存友好，但是会占用大量CPU去处理过期数据，影响吞吐量</li><li>惰性过期：只有访问一个key时，才会判断是否已过期，过期则清除。最大化节省CPU资源，对内存不友好。可能会导致大量过期的key因未被访问而无法清除。</li><li>定期过期：每隔一定时间，扫描一定数量的key，并删除其中过期的，通过调整定时扫描的时间间隔和扫描限定耗时，使CPU和内存达到一个最佳平衡状态。</li></ul></li></ol><ul><li>Redis中同时使用了惰性过期和定期过期两种策略。</li><li>每隔100ms就随机抽取一定量key，检查和删除。同时获取key时，会检查一下是否过期，过期则删除。</li><li>隐患：同样可能定期删除，漏删了大量过期key，也没有走惰性删除，就会导致大量过期key堆积在内存。</li></ul><ol start="3"><li>缓存淘汰算法</li></ol><ul><li><p>Redis 缓存淘汰算法用于在内存资源不足时，决定哪些数据需要从缓存中移除。Redis 提供了多种策略以应对不同的应用场景：</p><ol><li>volatile-lru（LRU for volatile keys）：<ul><li>当内存不足以容纳新写入的数据时，会优先剔除已设置过期时间的键值对，并根据LRU原则删除最近最少使用的数据。</li></ul></li><li>allkeys-lru：<ul><li>不区分是否设置了过期时间，所有键都会根据LRU规则淘汰，即删除最近最少使用的数据。</li></ul></li><li>volatile-ttl：<ul><li>同样针对设置了过期时间的键，但淘汰时不是基于访问频率而是基于键的剩余存活时间（TTL），选择TTL最短的键进行淘汰。</li></ul></li><li>noeviction：<ul><li>不进行任何数据淘汰，当内存满时，执行可能导致占用更多内存的命令将返回错误。</li></ul></li><li>allkeys-random：<ul><li>随机淘汰任意键，不论其是否被频繁使用或何时到期。</li></ul></li><li>volatile-random：<ul><li>淘汰一个随机的已设置过期时间的键。</li></ul></li></ol></li><li><p>值得注意的是，Redis 实现的 LRU 算法并不是精确的 LRU，因为为了性能考虑，它并没有真正维护一个完整的 LRU 链表结构。Redis 采用了一种近似 LRU 的实现方法：通过为每个键维护一个 lru 字段来记录最后一次访问的时间戳，在内存不足时，Redis 会选择一定数量（比如 5 个）的候选键，然后比较这些候选键的 lru 值，选择其中最小的一个进行淘汰。这样可以降低维护 LRU 数据结构的成本，同时在大部分情况下能够达到类似 LRU 的效果。</p></li></ul><h3 id="九、什么是缓存穿透？如何避免？"><a href="#九、什么是缓存穿透？如何避免？" class="headerlink" title="九、什么是缓存穿透？如何避免？"></a>九、什么是缓存穿透？如何避免？</h3><ul><li>本质：数据库和Redis都不存在</li><li>场景：查询id为-1的数据</li><li>坏处：每次都需要查询数据库和redis，增加磁盘IO的压力</li><li>解决方案：<ol><li>参数校验、屏蔽非法参数</li><li>数据库查询为空，可以给缓存一个空值或默认值，防止第二次再去数据库</li><li>使用布隆过滤器快速判断数据是否存在，将所有可能存在的数据哈希存到一个足够大的容器中，不存在的数据被这个bitmap拦截掉</li></ol></li><li>布隆过滤器的应用：<img width="100" src="/medias/avatars/5cc6a2b162424ca5944f5c4e90452c37.png"></li></ul><h3 id="十、什么是缓存雪崩？如何避免？"><a href="#十、什么是缓存雪崩？如何避免？" class="headerlink" title="十、什么是缓存雪崩？如何避免？"></a>十、什么是缓存雪崩？如何避免？</h3><ul><li><p>本质：数据库和Redis都存在，但redis都过期了</p></li><li><p>同一时间，缓存大面积失效，大量请求都直接去访问数据库<br>原因：</p><ol><li>Redis失效、宕机（故障）<ul><li>搭建Redis集群，主从架构</li><li>RDB持久化、IOF持久化</li><li>加入缓存组件：EHCache，搭建多级缓存（容易高并发的数据存入）</li><li>加入限流组件：hystrix，超过一定流量后，增加请求限制（保护数据处理层）</li></ul></li><li>Redis大量key的ttl过期<ul><li>ttl（过期时间）岔开，增加随机值，避免同一时间全部失效。<img width="100" src="/medias/avatars/fe44ca85df454d55939e774acd2cadb2.png"></li></ul></li></ol></li><li><p>解决方案：</p><ul><li>热点数据永不过期，或者通过异步线程在每次热点数据快要过期时，进行续期</li><li>数据的过期时间不要全一致，设为一定范围内的随机时间</li><li>并发量不高，可加入队列或者锁，限制同一时间访问数据库的阈值</li><li>分布式部署，将热点数据打散分不到多个节点</li><li>如果是缓存中间件宕机了，需要尽可能保证其高可用性，可以搭建redis集群，提前做好报警机制</li></ul></li></ul><h3 id="十一、缓存击穿"><a href="#十一、缓存击穿" class="headerlink" title="十一、缓存击穿"></a>十一、缓存击穿</h3><ul><li>本质：单个key没有或过期，同一时间查询这同一条数据并发量过多</li><li>解决方案：<ol><li>热点数据用不过期，或者通过异步线程在每次热点数据快要过期时，进行续期</li><li>使用互斥锁，避免大量请求同时查询数据库</li><li>熔断、降级、防止系统崩溃</li><li>还可以考虑对重要的热点数据进行多级缓存</li></ol></li></ul><h3 id="十二、Redis如何设计分布式锁"><a href="#十二、Redis如何设计分布式锁" class="headerlink" title="十二、Redis如何设计分布式锁"></a>十二、Redis如何设计分布式锁</h3><ul><li>概念：<ul><li>锁：同一时间只允许一个线程或者一个应用程序进入执行</li><li>分布式锁：必须要求Redis有【互斥】能力，可以使用SETNX命令：即key不存在了才会设置它的值，否则什么也不做。</li></ul></li><li>注意事项：<ol><li>如果过期时间是每个服务自己生成，需要保证每个客户端时间同步。</li><li>必须保存持有者唯一标识，否则可能被别的客户端释放/解锁。</li><li>给锁设置过期时间，以免进程挂了或异常了无法释放锁。</li><li>加入看门狗：开启守护线程，定期检测锁的失效时间，如果快过期了，业务还没有执行完，则续期。</li></ol></li><li>看门狗：开源框架Redisson，只要线程一个线程加锁成功，就会启动一个watch dog，每隔10秒检查一下锁是否释放，只要第一个线程还持有锁，就延长锁的失效时间，解决了锁过期但业务还没执行完的问题。</li></ul><h3 id="十三、什么是bigkey？会有什么影响？"><a href="#十三、什么是bigkey？会有什么影响？" class="headerlink" title="十三、什么是bigkey？会有什么影响？"></a>十三、什么是bigkey？会有什么影响？</h3><ol><li>概念：</li></ol><ul><li>key对应的value所占内存空间较大</li><li>例如一个字符串类型的value最大存到512M，一个列表类型的value最大可以存储2的32次方-1个元素。</li></ul><ol start="2"><li>字符串类型：</li></ol><ul><li>体现在单个value值特别大，一般认为超过10kb就是bigkey，和具体OPS相关（不同系统不同并发）。</li></ul><ol start="3"><li>非字符串类型：</li></ol><ul><li>哈希、列表、集合、有序集合，体现在元素个数过多。</li></ul><ol start="4"><li><p>危害：</p><ul><li>内存空间不均匀</li><li>超时堵塞：单线程操作bigkey比较耗时</li><li>网络拥塞：每次获取bigkey产生的网络流量较大</li><li>例如：一个bigkey为1MB，每秒访问为1000，则每秒产生1000MB的流量，普通千兆网（按照字节算是128MB/s）的服务器是灭顶之灾，而且服务器通常会采用单机多实例的方式来部署，可能会对其他实例造成影响。</li></ul></li><li><p>解决方案：value拆分</p></li></ol><h3 id="十四、Redis如何解决key冲突"><a href="#十四、Redis如何解决key冲突" class="headerlink" title="十四、Redis如何解决key冲突"></a>十四、Redis如何解决key冲突</h3><ol><li>业务隔离</li><li>key的设计</li></ol><ul><li>业务模块+系统名称+关键（id），针对用户可以加入（userid）</li></ul><ol start="3"><li>分布式锁</li></ol><ul><li>场景：多个客户端并发写key</li><li>客户端拿到锁，才能进行操作，避免多个客户端竞争该key</li></ul><ol start="4"><li>时间戳</li></ol><ul><li>key拼接时间戳，根据时间戳保证多个客户端的业务执行顺序</li></ul><h3 id="十五、怎么提高换成命中率"><a href="#十五、怎么提高换成命中率" class="headerlink" title="十五、怎么提高换成命中率"></a>十五、怎么提高换成命中率</h3><ol><li>提前加载</li><li>增加缓存的存储空间，增加缓存的数据</li><li>调整缓存的存储类型</li></ol><ul><li>例：对象通过Hash存储，而不用String。</li><li>根据业务做适当调整。</li></ul><ol start="4"><li>调整缓存的存储类型<ul><li>定时任务更新</li><li>MySQL通过检测binlog，将消息推送到Redis，更新缓存</li><li>通过Mq，业务更新修改数据时，通过MQ发送消息，消费更新缓存</li></ul></li></ol><h3 id="十六、Redis持久化方式有哪些方式？有什么区别？"><a href="#十六、Redis持久化方式有哪些方式？有什么区别？" class="headerlink" title="十六、Redis持久化方式有哪些方式？有什么区别？"></a>十六、Redis持久化方式有哪些方式？有什么区别？</h3><ol><li>持久化</li></ol><ul><li>将数据写入磁盘，避免因进程退出而造成的数据丢失，下次重启时通过持久化文件恢复数据。</li></ul><ol start="2"><li>RDB</li></ol><ul><li>通过快照（内存中数据在某一时刻的状态记录）的方式实现持久化，根据快照的触发条件，将内存的数据快照写入磁盘，以二进制的压缩文件进行存储。</li><li>缺点：每隔一段时间触发持久化，数据安全性低。</li></ul><ol start="3"><li>AOF</li></ol><ul><li>以独立日志的方式记录每次写的命令，重启时重新执行AOF文件中的命令恢复数据</li><li>AOF重写机制：AOF文件的大小达到某个阈值时，会将其中指令进行压缩。(如果有对于某个key多次的变更指令，则仅保留最新的数据指令)。</li><li>优化：<ul><li>因为AOF重写过程中需要读取当前内存中所有键值数据，性能较低，redis将其放在一个后台子线程中完成。</li><li>为了避免重写过程中出现数据变动，主进程的数据变更需要追加到AOF重写缓冲区中，等到AOF重写完成后，再把AOF重写换乘区里面的内容追加到新的AOF文件中。</li></ul></li><li>缺点：AOF文件可能过大，性能较差</li></ul><ol start="4"><li>混合式</li></ol><ul><li>如果执行bgrewriteaof命令，将内存中已有的数据以二进制格式存放在AOF文件中（模拟RDB），后续命令亦然采用AOF追加方式。</li><li>生产环境中一般采用两种持久化机制混合使用。</li><li>将内存中数据快照存储在AOF文件中（模拟RDB），后续再以AOF追加方式。</li><li>如果仅作为缓存使用，可以承受几分钟数据丢失，可以使用RDB，对主程序性能影响最小。<img width="100" src="/medias/avatars/d4ae5638b33c4a00ba7dc215d62d9f6a.png"></li></ul><h3 id="十七、为什么Redis需要把所有数据放到内存中？"><a href="#十七、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="十七、为什么Redis需要把所有数据放到内存中？"></a>十七、为什么Redis需要把所有数据放到内存中？</h3><ol><li><p>内存访问与磁盘访问的差距：</p><img width="100" src="/medias/avatars/fa449af16b4d41b0898eaa3e68b85f11.png"><ul><li>几乎是10倍以上，如果不是顺序读取而是随机读取效率会相差更大</li><li>同时还有CPU上下文切换的开销</li></ul></li><li><p>Redis通过异步，持久化将数据写入磁盘</p></li><li><p>随着技术的发展，硬件上来说内存也越来越便宜了</p></li><li><p>默认情况下，哪怕Redis内存不够了，也不会发生宕机，而是只可读不能写（Noeviction策略）</p></li><li><p>通过内存淘汰策略，确保整体服务正常运行</p></li></ol><h3 id="十八、如何保证缓存与数据库双写一致性？"><a href="#十八、如何保证缓存与数据库双写一致性？" class="headerlink" title="十八、如何保证缓存与数据库双写一致性？"></a>十八、如何保证缓存与数据库双写一致性？</h3><ol><li>新增数据类</li></ol><ul><li>新增数据时，数据会直接写入数据库，不用对缓存做任何操作；此时缓存没有新增数据，而数据库中最新值。</li></ul><ol start="2"><li>更新缓存类</li></ol><ul><li>（1）先更新缓存，在更新DB（一般不考虑）</li><li>原因：缓存更新成功，更新数据库时出现异常，会导致数据源与缓存数据完全不一致，而且很难察觉，因为缓存中的数据一直都存在。</li><li>（2）先更新DB，在更新缓存（一般不考虑）</li><li>原因：数据库更新成功了，缓存更新失败了，同样会导致数据源与缓存数据完全不一致，也很难察觉。</li></ul><ol start="3"><li>删除缓存</li></ol><ul><li>（3）先删除缓存，后更新DB</li><li>问题：</li><li>两个请求：A（更新）和B（查询）</li><li>A -&gt; 删除缓存中的数据 -&gt; 更新数据库</li><li>B -&gt; 查询缓存为空 -&gt; 查询数据库 -&gt; 补录到缓存</li><li>A -&gt; 还未更新成功/事务还未提交，B -&gt; 查询到的其实是数据库旧值</li><li>A -&gt; 还未更新成功/事务还未提交，B -&gt; 查询到的其实是数据库旧值</li><li>解决方案：</li><li>先淘汰缓存</li><li>再写数据库</li><li>休眠1秒，再次淘汰缓存</li><li>这个休眠的时间需要评估项目的读数据业务逻辑的耗时，确保请求结束时，写请求可以删除读请求造成的缓存脏数据。</li><li>（4）先更新DB，后删除缓存</li><li>查询：先读缓存 -&gt; 缓存没有就读数据库 -&gt; 取出数据放入缓存 -&gt; 同时返回响应。</li><li>更新：先更新数据库 -&gt; 删除缓存</li></ul><ol start="4"><li>如何选择</li></ol><ul><li><p>一般线上更多偏向于删除缓存类操作（容易避免问题）</p></li><li><p>原因：</p><ul><li>删除缓存比在DB中要快，所以一般先更新DB，后删除缓存</li><li>问题只会出现在查询比删除慢的情况，出现率相对最少</li><li>同时延迟双删可以有效避免缓存不一致情况。<img width="100" src="/medias/avatars/7190a8f437a1490eb13f3892b448d796.png"></li></ul></li><li><p>伪代码实现延迟双删：<br> redis.deykey(X)<br> db.update(X)<br> Thread.sleep(N)<br> redis.delKey(X)</p></li></ul><ol start="5"><li>读取binlog日志</li></ol><ul><li>异步删除、更新缓存，<ul><li>可以使用canal将binlog日志采集发送到MQ队列中。</li><li>通过ACK机制确认处理这条更新消息，删除缓存，保证数据一致性。<h3 id="十九、Redis集群方案"><a href="#十九、Redis集群方案" class="headerlink" title="十九、Redis集群方案"></a>十九、Redis集群方案</h3></li></ul></li><li>分布式解决方案 ：Redis Cluster</li><li>3.0版本推出</li><li>场景：单机内存、并发、流量等瓶颈</li><li>方案：</li><li>（1）客户端分区：</li><li>优点：分区逻辑可控</li><li>缺点：需要处理数据路由、高可用、故障转移等问题</li><li>（2）代理方案：</li><li>优点：简化客户端分布式逻辑，升级维护便利</li><li>缺点：加重架构部署复杂度和性能损耗</li></ul><ol start="2"><li>虚拟槽分区（0~16383）<img width="100" src="/medias/avatars/4a17080d64d1485f9f793488948b07e8.png"></li></ol><ul><li>主节点数量基本不可能超过1000个，节点连接需要不断发送ping/pong命令，消耗网络带宽</li></ul><ol start="3"><li>集群功能限制</li></ol><ul><li>（1）key批量操作支持有限：mset、mget仅支持相同slot值的key。</li><li>（2）key事务操作支持有限：仅支持在同一节点上的事务操作。</li><li>（3）key作为数据分区的最小颗粒度，不允许大的键值对（hash、list）映射在不同节点。</li><li>（4）不支持多数据库空间。单机为0-15（16个），集群模式仅能使用db0。</li><li>（5）复制结构仅支持一层，节点只能复制到主节点，不支持嵌套树状复制结构。</li></ul><ol start="4"><li>搭建集群</li></ol><ul><li>方式:</li><li>（1）Redis协议手工搭建。</li><li>（2）5.0之前有ruby语言脚本搭建。</li><li>（3）5.0之后搭建功能合并至redis-cli。</li><li>节点数至少奇数点个，官方推荐三主三从。</li></ul><h3 id="二十、Redis集群方案什么情况下会导致整个集群不可用？"><a href="#二十、Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="二十、Redis集群方案什么情况下会导致整个集群不可用？"></a>二十、Redis集群方案什么情况下会导致整个集群不可用？</h3><ul><li>A、B、C三个节点集群，B节点失败（主故障，且没有替代方案）整个集群都是不可用的。</li><li>集群不可用判定：</li><li>保护措施：默认情况下当16384个槽点任何一个没有指派到节点时，整个集群不可用。</li><li>主节点下线-&gt;故障发现-&gt;自动完成转移期间，整个集群为不可用状态。</li><li>可用通过设置cluster-require-full-coverage配置为no：主节点故障时，不影响其他主节点的可用性。</li></ul><h3 id="二十一、Redis集群会有写操作丢失吗？为什么？"><a href="#二十一、Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="二十一、Redis集群会有写操作丢失吗？为什么？"></a>二十一、Redis集群会有写操作丢失吗？为什么？</h3><ul><li>Redis无法保证数据的强一致性</li><li>一般只能向主节点写入数据，再异步同步到子节点</li><li>此时如果响应给客户端后还未异步同步成功时，主节点宕机了，子节点升至主节点，此时就会出现写入操作丢失。</li></ul><h3 id="二十二、Redis常见性能问题和解决方案"><a href="#二十二、Redis常见性能问题和解决方案" class="headerlink" title="二十二、Redis常见性能问题和解决方案"></a>二十二、Redis常见性能问题和解决方案</h3><ol><li>持久化 性能问题</li></ol><ul><li>早期仅支持全量复制-&gt;部分复制（一台机器性能开销过大）</li><li>因此开始配置主从 ：主节点不再做持久化而是交给从节点来做</li></ul><ol start="2"><li>数据比较重要，开启AOF。策略最好配置每秒同步。</li><li>主从复制 流畅，建议同一个局域网内操作，负责网络开销过大</li><li>尽量避免主库压力过大，增加从库</li><li>主从复制 尽量不要使用网状结构、线性结构</li></ol><h3 id="二十三、热点数据和冷数据"><a href="#二十三、热点数据和冷数据" class="headerlink" title="二十三、热点数据和冷数据"></a>二十三、热点数据和冷数据</h3><ol><li>热数据</li></ol><ul><li>访问频次较高，考虑使用缓存Redis</li><li>地图信息</li><li>点赞数、收藏数、分享数（不断变化）同步Redis</li><li>数据更新之前至少读取2次才能放缓存</li></ul><ol start="2"><li>冷数据</li></ol><ul><li>访问频次少</li><li>不需要放缓存</li></ul><h3 id="二十四、什么情况下可能会导致Redis阻塞"><a href="#二十四、什么情况下可能会导致Redis阻塞" class="headerlink" title="二十四、什么情况下可能会导致Redis阻塞"></a>二十四、什么情况下可能会导致Redis阻塞</h3><ol><li>客户端阻塞</li></ol><ul><li>命令执行时间过长： keys* Hgetall smembers 时间复杂度O(N)</li></ul><ol start="2"><li>BIGkey删除</li></ol><ul><li>需要释放大量占用内存 zset（100万的元素 删除大概需要2s）</li></ul><ol start="3"><li>清空库</li></ol><ul><li>flushdb flushall 涉及删除所有键值对</li></ul><ol start="4"><li>AOF日志同步写，记录AOF日志</li></ol><ul><li>大量写的操作</li><li>一个同步写磁盘操作大概耗时1~2ms</li></ul><ol start="5"><li>从库 加载RDB文件</li></ol><ul><li>RDB文件过大</li></ul><ol start="6"><li>Redis尽量部署在独立的服务器中</li></ol><ul><li>二十五、线上Redis响应慢处理思路<ol><li>紧急处理方案，扩容</li><li>生产环境查看Redis内存使用率，分析一定时间段内key数量变化</li></ol><ul><li>分析是否是大量数据未设置过期时间，或者是因为新版本迭代引起</li></ul><ol start="3"><li>清除bigkey，优化生成bigkey的代码块，调整未设置过期时间的代码块</li><li>根据业务场景调整淘汰策略</li></ol></li></ul><h3 id="二十六、-Redis-高可用"><a href="#二十六、-Redis-高可用" class="headerlink" title="二十六、 Redis 高可用"></a>二十六、 Redis 高可用</h3><ul><li>高可用：数据不能丢失（尽量减少丢失），保证Redis</li><li>26.1 主从模式</li><li>部署多台Redis服务器，主从复制以保证数据副本一致。主库通过将RDB文件发送给从库实现复制。</li><li>主从之间采用读写分离，主库写操作，从库仅负责读操作。</li><li>主库如果宕机了，人工切换一台从库称为主库，通知应用方更新主节点地址。</li><li>问题：数据不一致。</li><li>原因：主从库网络延迟，从库接收到命令，但它正在执行阻塞性命令。</li><li>解决方法：保证网络通畅，监控主从库复制进度。</li><li>26.2 哨兵模式</li><li>Redis从2.8开始提供哨兵机制。</li><li>####26.2.1 作用</li><li>监控：周期性ping主从库，检测是否挂了，标记下线状态。</li><li>自动选主切换：多个从库中按照一定规则选一个作为主库。</li><li>通知：选出主库后，将新主库的连接信息发送给其他从库以及应用方，重新建立联系。</li><li>26.2.2 哨兵</li><li>由一个或多个哨兵实例组成哨兵系统，监控其他Redis节点的同时，哨兵实例之间也互相监控。</li><li>哨兵之间通过发布订阅机制组成集群。一主多从</li><li>缺点：无法实现在线扩容，并发压力受限于单个服务器的资源配置。</li><li>26.3 Redis Cluster</li><li>哨兵模式解决了自动切换主从的问题，但是没有解决在线扩容的问题。</li><li>本质：Redis Cluster实现了Redis的分布式存储，每个节点存储不同的数据，实现数据分片。</li><li>引入Slot槽实现数据分片，每个节点分配一个Slot区间，当我们存取Key的时候，Redis根据key计算得到Slot值，找到对应的节点进行读写。多主多从。</li></ul><h3 id="二十七、布隆过滤器"><a href="#二十七、布隆过滤器" class="headerlink" title="二十七、布隆过滤器"></a>二十七、布隆过滤器</h3><ul><li>布隆过滤器可以应对缓存穿透问题</li><li>数据结构：一个很长的二进制向量和一组Hash映射函数组成。</li><li>作用：检索一个元素是否在一个集合中，空间查询效率比一般的算法要好的多。</li><li>缺点：有一定误识别率和删除困难。</li><li>原理：集合A中有n个元素，利用K个哈希散列函数，将A中每个元素映射到一个长度为a位的数组B中不同位置上。这些位置上的二进制数均设置为1。经过这个K个哈希散列函数映射后，发现其k个位置上的二进制数全部为1，这个元素很可能属于集合A。</li></ul><h3 id="二十八、Redis的理解"><a href="#二十八、Redis的理解" class="headerlink" title="二十八、Redis的理解"></a>二十八、Redis的理解</h3><ul><li>本质：基于Key-Value存储结构的非关系型数据库</li><li>数据类型：提供5种基本数据类型，String、set、zset、list、Map。</li><li>性能：基于内存存储，并且在数据结构上做了大量优化，IO性能较好。</li><li>作用：作为应用与数据库之间的分布式缓存组件。</li><li>高可用：提供了主从复制、哨兵、以及集群方式实现高可用，集群中通过hash槽的方式实现了数据分片，进一步提升了性能</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot面试题</title>
      <link href="/2024/01/22/springboot/"/>
      <url>/2024/01/22/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h1><ol><li>什么是SpringBoot？</li></ol><ul><li>SpringBoot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，<br>提供了各种启动器，开发者可以快速上手。</li></ul><ol start="2"><li>为什么要使用SpringBoot？</li></ol><ul><li>快速开发</li><li>快速整合第三方框架（Maven依赖关系，Maven继承）</li><li>简化XML的配置</li><li>内置嵌入HTTP服务器（Tomcat（默认）、Jetty），降低了对环境的要求</li></ul><ol start="3"><li>SpringBoot的优点？</li></ol><ul><li>容易上手，提升开发效率，为Spring开发提供一个更快、更简单的开发框架</li><li>远离繁琐的配置</li><li>提供一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li></ul><ol start="4"><li>SpringBoot的缺点</li></ol><ul><li>SpringBoot仅适用于全新Spring项目。将一个传统SpringFramework项目转换为SpringBoot应用程序是一个非常困难和耗时的过程</li><li>集成度较高，使用过程中不太容易了解底层</li></ul><ol start="5"><li>SpringBoot与SpringCloud区别</li></ol><ul><li>SpringBoot是快速开发的Spring框架，而SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot进行开发。</li></ul><ol start="6"><li>Spring 和SpringBoot有何不同？    </li></ol><ul><li>SpringBoot本质上是Spring框架的延伸和扩展，它的诞生是为了简化Spring框架初始搭建以及开发过程，使用它可以不再依赖Spring应用程序中的XML配置，为更快、更高效的开发Spring提供更加有力的支持。</li><li>更快速的构建能力：SpringBoot提供了更多的Starters用于快速构建业务框架，Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找依赖包</li><li>起步依赖：在创建SpringBoot时可以直接勾选依赖模块，这样在项目初始化时就会把相关依赖直接添加到项目中，大大缩短了查询并添加依赖的时间</li><li>内嵌容器支持：SpringBoot内嵌了Tomcat、Jetty、Undertow</li><li>Actuator监控：可以监控应用程序的运行状况，或者内存、线程池、Http请求统计等</li></ul><ol start="7"><li>SpringBootApplication引入了哪3个重要注解?</li></ol><ul><li>核心注解是@SpringBootApplication，它主要由@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan这三个构成：<br>  @SpringBootConfiguration 里面就只有一个 @Configuration 主要注解，也就是把该类变成一个配置类所以@SpringBootConfiguration 就相当于 @Configuration<br>  @EnableAutoConfiguration 是由 @AutoConfigurationPackage 和@Import(EnableAutoConfigurationImportSelector.class) 这两个组成的 @AutoConfigurationPackage 是自动配置包，包括了一个 @Import 注解，给容器导入了自动配置包的注册器，AutoConfigurationPackages.Registrar.class：将主启动类的所在包及包下面所有子包里面的所有组件扫描到 Spring 容器<br>  @ComponentScan：扫描包，该注解默认会扫描该类所在的包下所有的配置类</li></ul><ol start="8"><li>SpringBoot的配置文件由哪几种格式？它们有什么区别？<br> 主要有.properties 和 .yml，它们的区别主要是写的格式不同：<pre><code> .properties： user.name = jason .yml： user:     name: javastack .yml 格式不支持 @PropertySource 注解导入配置</code></pre></li><li>SpringBoot需要独立的容器运行吗？</li></ol><ul><li>不需要，因为已经内置了 Tomcat/ Jetty 等容器</li></ul><ol start="10"><li>你如何理解 Spring Boot 中的 Starters</li></ol><ul><li>个人理解 Spring Boot 就是由各种 Starter 组合起来的，我们自己也可以开发Starter。</li><li>当一个项目变得相当复杂，管理依赖会成为一个噩梦，因为当中涉及太多 artifacts 了。</li><li>这时候 SpringBoot starter 就派上用处了。其他所需的依赖以一致的方式注入并且被管理。</li><li>所有的 starter 都归于 org.springframework.boot 组中，并且它们都以由 spring-boot-starter- 开头取名。这种命名方式使得我们更容易找到 starter 依赖，特别是当我们使用那些支持通过名字查找依赖的 IDE 当中。</li><li>SpringBoot 提供了非常多的 starter ，其中最常用的是：</li><li>spring-boot-starter：核心 starter，包括自动化配置支持，日志以及 YAML</li><li>spring-boot-starter-aop：Spring AOP 和 AspectJ 相关的切面编程 starter</li><li>spring-boot-starter-data-jpa：使用 Hibernate Spring Data JPA 的 starter</li><li>spring-boot-starter-jdbc：使用 HikariCP 连接池 JDBC 的 starter</li><li>spring-boot-starter-security：使用 Spring Security 的 starter</li><li>spring-boot-starter-test：SpringBoot 测试相关的 starter</li><li>spring-boot-starter-web：构建 restful、springMVC 的 web应用程序的 starter</li></ul><ol start="11"><li>Spring Boot 可以兼容老 Spring 项目吗，如何做？</li></ol><ul><li>使用 @ImportResource 注解导入老 Spring 项目配置文件</li></ul><ol start="12"><li>Spring Boot 中读取配置的方式有哪些？</li></ol><ul><li>注入Environment对象：通过Environment 的 getProperty() 方法读取指定配置 Key 的内容</li><li>使用@Value注解，实现单个配置的注入</li><li>使用@ConfigurationProperties注解，实现一组配置的注入</li></ul><ol start="13"><li>SpringBoot 实现热部署有哪几种方式？ 热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中 主要有两种方式：</li></ol><ul><li>SpringLoaded</li><li>Spring-boot-devtools</li></ul><ol start="14"><li>Spring Boot 是否可以使用 XML 配置 ?</li></ol><ul><li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过@ImportResource 注解可以引入一个 XML 配置</li></ul><ol start="15"><li>如何实现 Spring Boot 应用程序的安全性？</li></ol><ul><li>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法</li></ul><ol start="16"><li>运行 Spring Boot 有哪几种方式？</li></ol><ul><li>打包用命令或者放到容器中运行</li><li>用 Maven/ Gradle 插件运行</li><li>直接执行 main 方法运行</li></ul><ol start="17"><li>开启 Spring Boot 特性有哪几种方式</li></ol><ul><li>继承spring-boot-starter-parent项目</li><li><parent>    <groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter-parent</artifactid>    <version>2.6.2</version>    <relativepath> <!-- lookup parent from repository --></relativepath></parent></li><li>导入spring-boot-dependencies项目依赖</li><li><parent>  <groupid>org.springframework.boot</groupid>  <artifactid>spring-boot-dependencies</artifactid>  <version>2.6.2</version></parent></li></ul><ol start="18"><li>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪一个？</li></ol><ul><li>Spring Boot 支持 Logging、Log4j2、Lockback 做为日志框架，若是你使用 Starters 启动器，Spring Boot 将使用 Logback 做为默认日志框架</li></ul><ol start="19"><li>Spring Initializr 是创建 Spring Boot 的唯一方法？</li></ol><ul><li>Spring Initiatlizr 让创建 Spring Boot 项目变的很容易，但是，也可以通过设置一个 maven 项目并添加正确的依赖项来开始一个项目</li><li>创建方式有两种：</li><li>第一种:：start.spring.io 方式创建</li><li>第二种：在项目的标题为 “Basic Web Application” 处进行手动设置</li></ul><ol start="20"><li>Spring Boot 内嵌了 Tomcat ，那什么是嵌入式服务器</li></ol><ul><li>我们在虚拟机上面部署应用程序需要几个步骤：</li><li>安装 Java</li><li>安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</li><li>部署应用程序 jar 或者 war 包</li><li>如果把这些步骤简化了，应该怎么做呢？</li><li>让我们来思考如何使服务器成为应用程序的一部分？</li><li>我们只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了</li><li>这就是嵌入式服务器的起源</li></ul><ol start="21"><li>前后端分离，如何维护接口文档<br>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便</li><li>Spring Boot中如何解决跨域问题？</li></ol><ul><li><p>跨域可以在前端通过JSONP来解决，但是JSONP只可以发送GET请求，无法发送其他类型的请求，在RESTful风格的应用中，就显得非常鸡肋，因此推荐在后端通过（CORS，Cross-origin resource sharing）来解决跨域问题。这种解决方案并非Spring Boot特有的，在传统的SSM框架中，就可以通过CORS来解决跨域问题，只不过之前我们是在XML文件中配置CORS，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题</p></li><li><p>@Configuration<br>public class CorsConfig implements WebMvcConfigurer {</p><p>  @Override<br>  public void addCorsMappings(CorsRegistry registry) {</p><pre><code>  registry.addMapping("/**")          .allowedOrigins("*")          .allowCredentials(true)          .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")          .maxAge(3600);</code></pre><p>  }</p></li></ul><p>}</p><ul><li><p>项目中前后端分离部署，所以需要解决跨域的问题。</p></li><li><p>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。</p></li><li><p>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。</p></li><li><p>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行</p></li><li><p>@Configuration<br>public class CorsConfig {</p><pre><code>@Beanpublic CorsFilter corsFilter() {    CorsConfiguration corsConfiguration = new CorsConfiguration();    corsConfiguration.addAllowedOrigin("*");    corsConfiguration.addAllowedHeader("*");    corsConfiguration.addAllowedMethod("*");    corsConfiguration.setAllowCredentials(true);    UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();    urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);    return new CorsFilter(urlBasedCorsConfigurationSource);}</code></pre><p>}</p></li></ul><ol start="23"><li>Spring Boot 约定优于配置的体现是什么？</li></ol><ul><li>Maven的目录结构：<ul><li>默认有 resources 文件夹存放配置文件</li><li>默认打包方式为jar</li><li>默认的配置文件：application.properties 或 application.yml 文件</li><li>默认通过 spring.profiles.active 属性来决定运行环境时的配置文件</li><li>EnableAutoConfiguration 默认对于依赖的 starter 进行自动装载</li><li>spring-boot-start-web 中默认包含 spring-mvc 相关依赖以及内置的 tomcat 容器，使得构建一个 web 应用更加简单</li></ul></li></ul><ol start="24"><li>内置容器的启动流程是什么</li></ol><ul><li>启动一个 Spring Boot项目，首先运行 Application 启动类的 main 方法，main 方法中调用了 SpringApplication.run 方法，run 方法中又调用了最核心的 refreshContext 方法，这里面又调用了我们最熟悉了 spring 容器启动模板方法refresh 方法，默认 Spring Boot 会启动 Tomcat，在 refresh 中的 onRefresh() 中执行；<br>onRefresh 调用了 createWebServer() 方法，通过 TomcatServletWebServerFactory 开始创建 Tomcat 实例；<br>最后在 refresh 方法中的 finishRefresh() 中调用 Tomcat 实例的 start 逻辑，并将应用上下文发布的 webServer 中，至此完成 Tomcat 的启动</li></ul><ol start="25"><li>你如何理解 Spring Boot 配置加载顺序？</li></ol><ul><li>Spring Boot 配置加载顺序优先级是:propertiese文件、YAML文件、系统环境变量、命令行参数。</li></ul><ol start="26"><li>application.properties 和 bootstrap.properties 有何区别 ?</li></ol><ul><li>bootstrap 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效, 而且 boostrap 里面的属性不能被覆盖；<br>application 用于 Spring Boot 项目的自动化配置</li></ul><ol start="27"><li>Spring Boot 中的监视器是什么？</li></ol><ul><li>Spring boot actuator 是 spring 启动框架中的重要功能之一，Spring boot 监视器可以访问生产环境中正在运行的应用程序的当前状态。监视器模块公开了一组可直接作为 HTTP URL 访问的 REST 端点来检查状态</li></ul><ol start="28"><li>如何使用 Spring Boot 实现异常处理？</li></ol><ul><li>Spring 通过使用 @ControllerAdvice 注解处理异常，实现一个ControllerAdvice 类来处理控制器类抛出的所有异常</li></ul><ol start="29"><li>YAML在springboot中的作用</li></ol><ul><li>使得 Spring Boot 配置文件更加有层次感，结构也比较清晰，不容易混淆，目前也是人类可读的数据序列化语言</li></ul><ol start="30"><li><p>如何使用 SpringBoot 实现分页和排序？<br>1、pom</p><!--分页插件--><pre><code>      &lt;dependency&gt;          &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;          &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;${pagehelper-version}&lt;/version&gt;      &lt;/dependency&gt;</code></pre><ul><li><p>配置文件<br>pagehelper:<br>helper-dialect: mysql<br>reasonable: true<br>support-methods-arguments: true<br>params: count=countSql</p></li><li><p>service层<br>   //用插件进行分页<br>   PageHelper.startPage(pageNum, pageSize);<br>   return articleMapper.findByPage();    </p></li><li><p>controller层<br>　　　　　通过service调用方法后获取数据。<br>　　　　　// 需要把Page包装成PageInfo对象才能序列化。该插件也默认实现了一个PageInfo<br>   PageInfo</p><article> pageInfo = new PageInfo&lt;&gt;(articles);</article><p></p></li></ul></li><li><p>Spring Boot 中如何实现定时任务 ?</p></li></ol><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li><li>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可</li></ul><ol start="32"><li>你使用了哪些 starter maven 依赖项？</li></ol><ul><li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li><li>spring-boot-starter-data-jpa 数据库支持</li><li>spring-boot-starter-data-Redis Redis数据库支持</li><li>spring-boot-starter-data-solr solr支持</li><li>mybatis-spring-boot-starter 第三方的mybatis集成starter<br>自己开发过的都可以说出来</li></ul><ol start="33"><li>Spring Boot 自动配置的原理</li></ol><ul><li>SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration</li><li>查看@EnableAutoConfiguration，其作用是利用AutoConfigurationImportSelector给容器中导入一些组件</li><li>查看AutoConfigurationImportSelector，其中public String[] selectImports(AnnotationMetadata annotationMetadata)方法内 最终调用getCandidateConfigurations()方法</li><li>查看 getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)，获取候选的配置，这个是扫描所有jar包类路径下”META-INF/spring.factories”</li><li>然后把扫描到的这些文件包装成Properties对象</li><li>从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把他们添加在容器中</li><li>整个过程就是将类路径下 “META-INF/spring.factories” 里面配置的所有 EnableAutoConfiguration 的值加入到容器中</li></ul><ol start="34"><li>SpringBoot核心配置文件是什么？</li></ol><ul><li>bootstrap.properties 和 application.properties</li></ul><ol start="35"><li><p>如何监视所有 SpringBoot 微服务？<br>创建SpringBoot Web项目，引入下列pom坐标</p><dependency>  <groupid>de.codecentric</groupid>  <artifactid>spring-boot-admin-starter-server</artifactid>  <version>2.5.1</version></dependency><dependency><h1 id="在你的启动类上添加：-EnableAdminServer注解"><a href="#在你的启动类上添加：-EnableAdminServer注解" class="headerlink" title="在你的启动类上添加：@EnableAdminServer注解"></a>在你的启动类上添加：@EnableAdminServer注解</h1><p>在你需要监控的服务中加入下列pom坐标</p><dependency> <groupid>de.codecentric</groupid> <artifactid>spring-boot-admin-starter-client</artifactid> <version>2.5.1</version></dependency><p>在需监控服务中配置：<br>spring.boot.admin.client.url=<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> （监控服务url）<br>management.endpoints.web.exposure.include=*</p></dependency></li><li><p>Spring Boot 打成的 jar 和普通的 jar 有什么区别</p></li></ol><ul><li>Spring Boot 打成jar包可以直接通过 java -jar *.jar 启动项目，但是不能够像普通 jar 包一样被其他项目引用。</li><li>普通 jar 解压后就是包名，可以直接引用内部的类，而 Spring Boot 解压后 BOOT/classes 目录下才是真正的代码，因此不能被直接引用，如果需要被引用可以配置 pom，将 SpringBoot 打包成两个 jar 包，一个可执行，一个可引用</li></ul><table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue面试题</title>
      <link href="/2024/01/22/vue/"/>
      <url>/2024/01/22/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><ol><li>Vue优点？</li></ol><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十KB；</li><li>简单易学：国人开发，中文文档，不存在语言障碍，易于理解和学习；</li><li>双向数据绑定：保留了react的特点，在数据操作方面更为简单；</li><li>组件化：保留了react的优点，实现了HTML的封装和重用，在构建单页面应用方面于着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟DOM：dom操作是非常耗费性能的，不在使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</li><li>运行速度更快：相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</li></ul><ol start="2"><li>vue父组件向子组件传递数据？</li></ol><ul><li>通过props</li></ul><ol start="3"><li>子组件像父组件传递事件？</li></ol><ul><li>$emit方法</li></ul><ol start="4"><li>v-show和v-if指令的共同点和不同点？</li></ol><ul><li>共同点：都能控制元素的显示和隐藏；</li><li>不同点：实现本质方法不同，v-show本质就是通过控制css中的display设置为none，控制隐藏，只会编译一次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。总结：如果要频繁切换某节点，使用v-show（切换开销较小，初始开销大）。如果不需要频繁切换某节点使用v-if（初始渲染开销较小，切换开销比较大）。</li></ul><ol start="5"><li>如何让CSS只在当前组件中起作用？</li></ol><ul><li>在组件中的style前面加上scoped</li></ul><ol start="6"><li><keep-alive></keep-alive>的作用是什么？</li></ol><ul><li>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li></ul><ol start="7"><li>如何获取DOM？</li></ol><ul><li>ref=”doomName”用法：this.$refs.domName</li></ul><ol start="8"><li>说出几种Vue当中的指令和它的用法？</li></ol><ul><li>v-model双向数据绑定；</li><li>v-for循环；</li><li>v-if v-show显示和隐藏；</li><li>v-no事件；</li><li>v-once：只绑定一次。</li></ul><ol start="9"><li>vue-loader是什么？使用它的用途有哪些？</li></ol><ul><li>Vue文件的一个加载器，将template/js/style转换成js模块。</li><li>用途：js可以写es6、style样式可以scss或less、template可以加jade等</li></ul><ol start="10"><li>为什么使用key？</li></ol><ul><li>需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。作用主要是为了高效的更新虚拟DOM。</li></ul><ol start="11"><li>axios及安装</li></ol><ul><li>请求后台资源模块。npm i axios -sava 装好，js使用import进来，然后使用.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。 </li></ul><ol start="12"><li>v-model的使用</li></ol><ul><li>v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：v-bind绑定一个value属性；v-on指令给当前元素绑定input事件。</li></ul><ol start="13"><li>请说出Vue。cli项目中src目录每个文件夹和文件的用法？</li></ol><ul><li>assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置；app.vue是一个应用主组件；main.js是入口文件。</li></ul><ol start="14"><li>分别简述computed和watch的使用场景</li></ol><ul><li>computed：当一个属性受多个属性影响的时候就需要用到computed，最典型的例子：购物车结算的时候</li><li>watch:当一条数据影响多条数据的时候就需要用watch，例子：搜索数据</li></ul><ol start="15"><li>v-on可以监听多个方法吗？</li></ol><ul><li>可以，例子：<input type="text" v-no="{input:onInput,focus:onFocus,blur:onBlur,}">。</li></ul><ol start="16"><li>$nextTick的使用</li></ol><ul><li>当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，你需要使用$nextTick这个回调，让修改后的data值渲染更新到DOM元素之后在获取，才能成功。</li></ul><ol start="17"><li>Vue组件中data为什么必须是一个函数？</li></ol><ul><li>因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。组建的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。</li></ul><ol start="18"><li>渐进式框架的理解</li></ol><ul><li>主张最少；可以根据不同的需求选择不同的层级；</li></ul><ol start="19"><li>Vue中双向数据绑定是如何实现的？</li></ol><ul><li>Vue双向数据绑定是通过数据劫持结合发布订阅模式的方式来实现的，也就是说数据库和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；</li><li>核心：关于Vue双向数据绑定，其核心是Object。defineProperty()方法。</li></ul><ol start="20"><li>单页面应用和多页面应用区别及优缺点</li></ol><ul><li>单页面应用（SPA）,通俗一点说是指只有一个主页面的应用，浏览器一开始要加载所有必须的HTML、JS、CSS。所有页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候路由动态载入，单页面的页面跳转，仅刷新局部资源。多用于pc端。</li><li>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</li><li>单页面的优点：用户体验好，快，内容改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的转场动画）。</li><li>单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</li></ul><ol start="21"><li>v-if和v-for的优先级</li></ol><ul><li>当v-if与v-for一起使用时，v-for具有比v-if更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中。所以，不推荐v-if和v-for同时使用。如果v-if和v-for一起用的话，Vue中的会自动提示v-if应该放到外层去。</li></ul><ol start="22"><li>assets和static的区别</li></ol><ul><li>相同点：assets和static两个都是存放在静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</li><li>不相同点：assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传到服务器。static中放置的静态资源文件就不会要打包压缩格式化等流程，而是直接进入打包好的目录，直接上传到服务器。因此避免了压缩直接进行上传，在打包时会提高一定效率，但是static中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大空间。</li><li>建议：将项目中template需要的样式文件JS文件等都可以放置在assets中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。</li></ul><ol start="23"><li>Vue常用的修饰符</li></ol><ul><li>.stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡。</li><li>.prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）</li><li>.capture：与事件冒泡的方向相反，事件捕获由外到内；</li><li>.self：只会触发自己范围内的事件，不包含子元素；</li><li>.once：只会触发一次。</li></ul><ol start="24"><li>Vue的两个核心点</li></ol><ul><li>数据驱动、组件系统</li><li>数据驱动：viewModel，保证数据和视图的一致性。</li><li>组件系统：应用类UI可以看作全部是由组件树构成的。</li></ul><ol start="25"><li>Vue和jQuery的区别</li></ol><ul><li>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val();，它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和view完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和view是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</li></ul><ol start="26"><li>引进组件的步骤</li></ol><ul><li>在template中引入组件；在script的第一行用import引入路径；用component中写上组件名称。</li></ul><ol start="27"><li>delete和Vu。delete删除数组的区别</li></ol><ul><li>delete只是被删除的元素变成了empty/undefined其他的元素的键值还是不变。Vue.delete直接删除了数组改变了数据的键值。</li></ul><ol start="28"><li>SPA首屏加载慢如何解决</li></ol><ul><li>安装动态懒加载所需插件；使用CDN资源。</li></ul><ol start="29"><li>Vue-router跳转和location.href有什么区别</li></ol><ul><li>使用laocation.href=’/url’来跳转，简单方便，但是刷新了页面；使用histaory.pushState(‘/url’)，无刷新页面，静态跳转；引进router，然后使用router.push(‘/url’)来跳转，使用了diff算法，实现了按需加载，减少了DOM的消耗。其实使用router跳转和使用histaory.pushState()没什么区别的，因为vue-router就是用了histaory.pushState()，尤其是在histaory模式下。</li></ul><ol start="30"><li>Vue slot</li></ol><ul><li>简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。</li></ul><ol start="31"><li>你们Vue项目是打包了JS文件，一个css文件，还是多个文件？</li></ol><ul><li>根据Vue-cli脚手架规范，一个JS文件，一个css文件。</li></ul><ol start="32"><li>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？</li></ol><ul><li>Vue路由在Android机上有问题，babel问题，安装babel plypill插件解决。</li></ul><ol start="33"><li>Vue2中注册在router-link上事件无效解决方法</li></ol><ul><li>使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件。</li></ul><ol start="34"><li>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</li></ol><ul><li>方法一：只用a标签，不适用button标签；方法二：使用button标签和Router.navigate方法</li></ul><ol start="35"><li>axios的特点有哪些</li></ol><ul><li>从浏览器中创建XMLHttpRequest；</li><li>node.js创建http请求；</li><li>支持PromiseAPI；</li><li>拦截请求和响应；</li><li>转换请求数据和响应数据；</li><li>取消请求；</li><li>自动转换成JSON。</li><li>axios中的发送字段的参数是data跟params两个，两者的区别在于params是跟请求地址一起发送的，data的作为一个请求体进行发送params一般适用于get请求，data一般适用于post put请求。</li></ul><ol start="36"><li><p>请说下封装Vue组件的过程？</p><ol><li>建立组件模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。</li><li>准备好组件的数据输入。即分析好逻辑，定好props里面的数据、类型。</li><li>准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。</li><li>封装完毕了，直接调用即可。</li></ol></li><li><p>params和query的区别</p></li></ol><ul><li>用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$router.params.name。url地址显示：query更加类似于我们Ajax中get传参，parms则类似于post，说的在简单一点，前者在浏览器地址栏中显示参数，后者则不显示</li></ul><ol start="38"><li>Vue初始化页面闪动问题</li></ol><ul><li>使用Vue开发时，在Vue初始化之前，由于div是不归Vue管的，所以我们写代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是要必要让解决这个问题的。首先：在css里面加上[v-cloak]{display: none;}。如果没有彻底解决问题，则在根元素加上style=”display:none;”:style=”{display:’block’}”</li></ul><ol start="39"><li>Vue更新数组时触发视图更新方法</li></ol><ul><li>push();pop();shift();unshift();sort();reverse()</li></ul><ol start="40"><li>Vue常用的UI组件库</li></ol><ul><li>Mint,Element,VUX</li></ul><ol start="41"><li>Vue修改打包后静态资源路径的修改</li></ol><ul><li>cli2版本：将config/index.js里的assetsPublicPath的值改为’./‘。<br>  build: { <pre><code>  // ...   assetsPublicPath: './',   // ...  </code></pre>  } </li><li>cli3版本：在根目录下新建Vue.config.js文件，然后加上以下内容：（如果已经有此文件就直接修改）<br>  module.exports = { <pre><code>  publicPath: '', // 相对于 HTML 页面（目录相同）    </code></pre>  } <h1 id="生命周期函数面试题篇"><a href="#生命周期函数面试题篇" class="headerlink" title="生命周期函数面试题篇"></a>生命周期函数面试题篇</h1><h3 id="42-什么是Vue生命周期？有什么作用？"><a href="#42-什么是Vue生命周期？有什么作用？" class="headerlink" title="42. 什么是Vue生命周期？有什么作用？"></a>42. 什么是Vue生命周期？有什么作用？</h3></li><li>每个Vue实例在被创建时都要经过一系列的初始化过程————例如：需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如：如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗，那我们最早可在mounted中进行。</li></ul><ol start="43"><li>第一次页面加载会触发哪几个钩子？</li></ol><ul><li>beforeCreate,created,beforeMount,mounted。</li></ul><ol start="44"><li>简述每个周期具体适合哪些场景</li></ol><ul><li>beforeCreate：在new应该Vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法</li><li>create： data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作</li><li>beforeMount： 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的</li><li>mounted： 执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行</li><li>beforeUpdate： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步</li><li>updated： 页面显示的数据和data中的数据已经保持同步了，都是最新的</li><li>beforeDestory： Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁</li><li>destroyed： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。</li></ul><ol start="45"><li>created和mounted的区别</li></ol><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><ol start="46"><li>vue获取数据在哪个周期函数</li></ol><ul><li>一般 created/beforeMount/mounted 皆可. 比如如果你要操作 DOM , 那肯定 mounted 时候才能操作。</li></ul><ol start="47"><li>请详细说下你对vue生命周期的理解？</li></ol><ul><li>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</li><li>创建前/后： 在beforeCreated阶段，vue实例的挂载元素 $el 和 数据对象 data 都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了， $el 还没有。</li><li>载入前/后： 在beforeMount阶段，vue实例的 $el 和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</li><li>更新前/后： 当data变化时，会触发beforeUpdate和updated方法。</li><li>销毁前/后： 在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</li></ul><h1 id="vue-路由面试题篇"><a href="#vue-路由面试题篇" class="headerlink" title="vue 路由面试题篇"></a>vue 路由面试题篇</h1><ol start="48"><li>mvvm 框架是什么？</li></ol><ul><li>vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</li></ul><ol start="49"><li>vue-router 是什么?它有哪些组件</li></ol><ul><li>vue用来写路由一个插件。router-link、router-view</li></ul><ol start="50"><li>active-class 是哪个组件的属性？</li></ol><ul><li>vue-router模块的router-link组件。children数组来定义子路由</li></ul><ol start="51"><li>怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</li></ol><ul><li>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id。</li></ul><ol start="52"><li>vue-router 有哪几种导航钩子?</li></ol><ul><li>三种，</li><li>第一种： 是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。</li><li>第二种： 组件内的钩子</li><li>第三种： 单独路由独享组件</li></ul><ol start="53"><li><code>$route</code> 和 <code>$router</code> 的区别</li></ol><ul><li>$router 是VueRouter的实例，在script标签中想要导航到不同的URL,使用 $router.push 方法。返回上一个历史history用 $router.to(-1)</li><li>$route 为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</li></ul><ol start="54"><li>vue-router的两种模式</li></ol><ul><li>hash模式： 即地址栏 URL 中的 # 符号；</li><li>history模式： window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。</li></ul><ol start="55"><li>vue-router实现路由懒加载（ 动态加载路由 ）</li></ol><ul><li>三种方式</li><li>第一种： vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。</li><li>第二种： 路由懒加载(使用import)。</li><li>第三种： webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</li></ul><h1 id="vuex常见面试题篇"><a href="#vuex常见面试题篇" class="headerlink" title="vuex常见面试题篇"></a>vuex常见面试题篇</h1><ol start="56"><li>vuex是什么？怎么使用？哪种功能场景使用它？</li></ol><ul><li>vue框架中状态管理。在main.js引入store，注入。</li><li>新建了一个目录store.js，….. export 。</li><li>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</li></ul><ol start="57"><li>vuex有哪几种属性？</li></ol><ul><li>有五种，分别是 State、 Getter、Mutation 、Action、 Module</li><li>state =&gt; 基本数据(数据源存放地)</li><li>getters =&gt; 从基本数据派生出来的数据</li><li>mutations =&gt; 提交更改数据的方法，同步！</li><li>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</li><li>modules =&gt; 模块化Vuex</li></ul><ol start="58"><li>Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</li></ol><ul><li>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</li><li>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</li><li>以上面试题仅供个人学习，如有错误请指正。谢谢。</li></ul><table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2024/01/22/springcloud/"/>
      <url>/2024/01/22/springcloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h1 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h1><ul><li>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</li><li>SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注Netflix，Neflix包含了四大组件：<ul><li>Eureka ：服务注册中心，用于实现服务的注册和发现</li><li>Ribbon：客户端负载均衡器，主要提供客户侧的负载均衡算法</li><li>Hystrix：断路器，保护系统，控制故障范围</li><li>Zuul：API网关，提供路由、负载均衡等多个作用</li><li>以及另一个子项目 Config：配置中心，实现配置统一管理</li></ul></li></ul><h1 id="SpringCloud基本概念：集群和分布式"><a href="#SpringCloud基本概念：集群和分布式" class="headerlink" title="SpringCloud基本概念：集群和分布式"></a>SpringCloud基本概念：集群和分布式</h1><ul><li>集群：<ul><li>假设现在有一家小饭店，厨房只有一个厨师，他需要干买菜、洗菜、切菜、炒菜所有工作</li><li>当饭店生意火爆时，一个厨师忙不过来，于是老板再请了一个一样的厨师，两个厨师能炒一样的菜，这两个厨师的关系是集群</li><li>应用服务器集群部署</li></ul></li><li>分布式：<ul><li>随着菜系品种增多，一个厨师无法处理整个的一套流程工作，所以老板专门聘请了采购、配菜师，此时采购、配菜师和厨师的关系是分布式</li><li>多个采购、多个配菜师之间的关系也是集群</li><li>应用服务器的业务拆分、分布式部署<h1 id="分布式架构的演变之路"><a href="#分布式架构的演变之路" class="headerlink" title="分布式架构的演变之路"></a>分布式架构的演变之路</h1></li></ul></li><li>阶段一:单应用架构<ul><li>系统的初级都是应用和数据库都放在一台服务器上。</li></ul></li><li>阶段二:应用服务器和数据库服务器分离</li><li>阶段三:应用服务器集群<ul><li>随着访问量和流量的增加,假设数据库没有遇到瓶颈,对应用服务器集群来对请求进行分流,提高程序的性能。</li></ul></li><li>阶段四:数据库压力变大-数据库读写分离<ul><li>读写分离的话,这样以后的请求，查询的请求就可以去从库里面读数据,写的数据可以到主库中了</li></ul></li><li>阶段五:使用搜索引擎、引入缓存机制缓解数据库的压力</li><li>阶段六:数据库的水平/垂直拆分</li><li>阶段七:应用的拆分<ul><li>随着业务的发展,业务越来越多,应用的压力越来越大。工程规模也越来越庞大。这个时候就可以考虑将应用拆分,按照领域模型将我们的用户，商品，交易分拆成子系统。<h1 id="微服务概念："><a href="#微服务概念：" class="headerlink" title="微服务概念："></a>微服务概念：</h1></li></ul></li><li>微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。 </li><li>在微服务架构系统中，围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。</li></ul><h1 id="Spring-Cloud和dubbo对比"><a href="#Spring-Cloud和dubbo对比" class="headerlink" title="Spring Cloud和dubbo对比"></a>Spring Cloud和dubbo对比</h1><ul><li>dubbo由于是二进制的传输，占用带宽会更少</li><li>springCloud是http协议传输，带宽占用会比较多，同时使用http协议一般会使用JSON报文，消耗会更大</li><li>dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决</li><li>springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级</li><li>dubbo的注册中心可以选择zk,redis等多种，springcloud的注册中心只能用eureka或者自研</li></ul><h1 id="Eureka-服务注册中心"><a href="#Eureka-服务注册中心" class="headerlink" title="Eureka 服务注册中心"></a>Eureka 服务注册中心</h1><ul><li>作用：实现服务治理（服务注册与发现）</li><li>简介：Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。由两个组件组成：Eureka服务端和Eureka客户端。</li><li>Eureka服务端用作服务注册中心。支持集群部署。</li><li>Eureka客户端是一个java客户端，用来处理服务注册与发现。</li><li>在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</li></ul><h1 id="创建服务注册中心的步骤"><a href="#创建服务注册中心的步骤" class="headerlink" title="创建服务注册中心的步骤"></a>创建服务注册中心的步骤</h1><ul><li>创建一个maven主工程，命名为spring-cloud</li><li>创建一个Module子工程，该工程作为服务注册中心，命名为Eureka-server</li><li>创建一个服务提供者，即一个Module子工程，命名为service-hello，在配置文件中，将该服务注册在Eureka-server中</li><li>测试服务的多端口同时启动，观察Eureka-server中的信息</li><li>了解高可用性的服务注册中心。</li></ul><h1 id="Maven主工程创建"><a href="#Maven主工程创建" class="headerlink" title="Maven主工程创建"></a>Maven主工程创建</h1><ul><li>创建一个Maven主工程，命名为Spring-Cloud，在其pom文件引入依赖，spring Boot版本为2.1.6.RELEASE，Spring Cloud版本为Finchley.RELEASE。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他module工程继承该pom  <parent>      <groupid>org.springframework.boot</groupid>      <artifactid>spring-boot-starter-parent</artifactid>      <version>2.1.6.RELEASE</version>      <relativepath> <!-- lookup parent from repository -->  </relativepath></parent>  <!--包名-->  <groupid>com.nothing</groupid>  <!--项目名-->  <artifactid>springcloud</artifactid>  <version>0.0.1-SNAPSHOT</version>  <name>springcloud</name>  <description>Demo project for Spring Boot</description>  <parent>      <groupid>org.springframework.boot</groupid>      <artifactid>spring-boot-starter-parent</artifactid>      <version>2.1.6.RELEASE</version>      <relativepath> <!-- lookup parent from repository -->  </relativepath></parent>  <!--包名-->  <groupid>com.nothing</groupid>  <!--项目名-->  <artifactid>springcloud</artifactid>  <version>0.0.1-SNAPSHOT</version>  <name>springcloud</name>  <description>Demo project for Spring Boot</description></li><li>主工程pom文件中添加spring-boot-starter和spring-boot-starter-test两个依赖包，添加一个spring-boot-maven-plugin的插件，添加一个依赖版本管理器。<dependencies>      <!--spring boot启动包-->      <dependency>          <groupid>org.springframework.boot</groupid>          <artifactid>spring-boot-starter</artifactid>      </dependency>      <!--spring boot测试包-->      <dependency>          <groupid>org.springframework.boot</groupid>          <artifactid>spring-boot-starter-test</artifactid>          <scope>test</scope>      </dependency>  </dependencies>  <dependencymanagement>      <dependencies>          <dependency>              <groupid>org.springframework.cloud</groupid>              <artifactid>spring-cloud-dependencies</artifactid>              <version>${spring-cloud.version}</version>              <type>pom</type>              <scope>import</scope>          </dependency>      </dependencies>  </dependencymanagement>  <build>      <plugins>          <!--spring-boot集成maven的插件-->          <plugin>              <groupid>org.springframework.boot</groupid>              <artifactid>spring-boot-maven-plugin</artifactid>          </plugin>      </plugins>  </build></li></ul><h1 id="搭建服务注册中心子项目Eureka-server"><a href="#搭建服务注册中心子项目Eureka-server" class="headerlink" title="搭建服务注册中心子项目Eureka-server"></a>搭建服务注册中心子项目Eureka-server</h1><ul><li><p>右键工程-&gt;创建model-&gt; 选择spring initialir</p></li><li><p>点击next ，Group填写包名  artifact填写项目名，命名为eureka-server</p></li><li><p>点击next，选中spring cloud discovery，在中间选项中勾选上Eureka server</p></li><li><p>在pom文件中，继承主工程pom文件，添加spring-cloud-starter-netflix-eureka-server依赖包。</p>  <parent>      <groupid>com.nothing</groupid>      <artifactid>springcloud</artifactid>      <version>0.0.1-SNAPSHOT</version>      <relativepath> <!-- lookup parent from repository -->  </relativepath></parent>  <dependencies>      <!--eureka-server依赖包-->      <dependency>          <groupid>org.springframework.cloud</groupid>          <artifactid>spring-cloud-starter-netflix-eureka-server</artifactid>      </dependency>  </dependencies></li><li><p>项目创建好后，结构如下，其中EurekaServiceApplication为springboot启动类，在该启动类中添加一个注解@EnableEurekaServer<br>@SpringBootApplication<br>@EnableEurekaServer<br>public class EurekaServerApplication {<br>  public static void main(String[] args) {</p><pre><code>  SpringApplication.run(EurekaServerApplication.class, args);</code></pre><p>  }<br>}</p></li><li><p>项目配置文件采用yml的配置语法：</p><ul><li>其中spring.application.name是唯一的，表明自己的服务名</li><li>Server.port是唯一的，表示启动该项目所用的tomcat端口</li><li>Eureka.instance.hostname表明该注册中心的ip地址<br>#端口名<br>server:<br>  port: 8761<br>eureka:<br>instance:<br>  hostname: localhost<br>#表明自己是一个server<br>client:<br>  registerWithEureka: false #表明当前项目只作为服务器，不作为客户端<br>  fetchRegistry: false #只注册自身<br>serviceUrl:<br>defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/<br>spring:<br>  application:<pre><code>  name: eurka-server</code></pre></li><li>完成上面所有配置后，启动EurekaServerApplication启动类，在浏览器中访问<a href="http://localhost:8761/其中Application处是所有注册在注册中心的服务列表，当前没有任何服务注册" target="_blank" rel="noopener">http://localhost:8761/其中Application处是所有注册在注册中心的服务列表，当前没有任何服务注册</a><br>General info是key-value格式的当前注册中心的相关信息<br>Instance info是当前所有在运行的注册中心实例的信息<h1 id="开发一个微服务"><a href="#开发一个微服务" class="headerlink" title="开发一个微服务"></a>开发一个微服务</h1></li></ul></li><li><p>创建一个子项目Module，命名为service-hello，创建过程和eureka-server类似，但不需要勾选eureka-server选项。</p></li><li><p>pom文件继承主工程pom文件，并添加两个依赖：spring-cloud-starter-netflix-eureka-client和spring-boot-starter-web</p>  <parent>          <groupid>com.nothing</groupid>          <artifactid>springcloud</artifactid>          <version>0.0.1-SNAPSHOT</version>  </parent>  <dependencies>      <!--eureka客户端依赖-->      <dependency>          <groupid>org.springframework.cloud</groupid>          <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>      </dependency>      <!--spring-boot-web依赖-->      <dependency>          <groupid>org.springframework.boot</groupid>          <artifactid>spring-boot-starter-web</artifactid>      </dependency>  </dependencies></li><li><p>配置文件如下：</p></li><li><p>Server.port指明当前项目的端口为8005</p></li><li><p>Spring.application.name指明当前服务的名称，服务与服务间的调用，后面的客户端调用服务，都是根据该名称</p></li><li><p>Eureka.client.serviceUrl.defaultZone指明该服务注册中心地址，即是我们刚刚部署启动的eureka-server<br>  server:<br>  port: 8762<br>  #服务的name，服务与服务之间互相调用都是根据该name<br>  spring:<br>  application:</p><pre><code>  name: service-hello</code></pre><p>  #指明服务注册中心的地址<br>  eureka:<br>  client:</p><pre><code>  serviceUrl:  defaultZone: http://localhost:8761/eureka/</code></pre></li><li><p>在spring-boot启动类中，加上一个注解@EnableEurekaClient，表明自己是一个服务提供方。</p></li><li><p>在启动类的子目录或同级目录下，编写HelloController，代码如下：<br>  @EnableEurekaClient<br>  @SpringBootApplication<br>  public class ServiceHelloApplication {</p><pre><code>  public static void main(String[] args) {      SpringApplication.run(ServiceHelloApplication.class, args);  }</code></pre><p>  }</p></li><li><p>启动service-hello，访问服务注册中心地址: <a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> 可以看到我们的service-hello微服务已经注册在eureka-server中，这时可以直接访问微服务的地址端口，并附带参数gcm  <a href="http://localhost:8005/hello?name=gcm" target="_blank" rel="noopener">http://localhost:8005/hello?name=gcm</a> 可以看到浏览器打印出控制器返回的信息</p></li></ul><h1 id="Ribbon简介"><a href="#Ribbon简介" class="headerlink" title="Ribbon简介"></a>Ribbon简介</h1><ul><li>在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。</li><li>Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。</li><li>ribbon是一个客户端负载均衡器，可以很好的控制http和tcp的一些行为。Feign默认集成了ribbon。</li></ul><h1 id="Ribbon与负载均衡"><a href="#Ribbon与负载均衡" class="headerlink" title="Ribbon与负载均衡"></a>Ribbon与负载均衡</h1><ul><li>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</li><li>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</li><li>Spring Cloud Ribbon虽然只是一个工具类框架，它不像服务注册中心、配置中心、API网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的<h1 id="restTemplate详解"><a href="#restTemplate详解" class="headerlink" title="restTemplate详解"></a>restTemplate详解</h1></li><li>restTemplate可以使用REST风格的http请求去调用服务注册中心的微服务；<br>其中主要的方法有：</li><li>GET请求：<ul><li>getForEntity函数</li><li>发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象</li><li>getForObject函数 </li><li>发送一个HTTP GET请求，返回的请求体将映射为一个对象</li></ul></li><li>POST请求：<ul><li>postForEntity() 函数 </li><li>POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得到的</li><li>postForObject() 函数 </li><li>POST 数据到一个URL，返回根据响应体匹配形成的对象</li></ul></li><li>DELETE请求：<ul><li>delete()函数 </li><li>在特定的URL上对资源执行HTTP DELETE操作</li></ul></li><li>PUT请求：<ul><li>put()函数 </li><li>PUT 资源到特定的URL</li></ul></li><li>其他请求：<ul><li>postForLocation()函数 </li><li>POST 数据到一个URL，返回新创建资源的URL</li><li>execute()函数 </li><li>在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象</li><li>exchange() 函数</li><li>在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中 映射得到的</li></ul></li></ul><h1 id="什么是-feign"><a href="#什么是-feign" class="headerlink" title="什么是 feign"></a>什么是 feign</h1><ul><li>Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。 Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用HttpMessageConverters 等。</li><li>Feign 也是一种声明式、模板化的 HTTP 客户端。在 Spring Cloud 中使用 Feign，可以做到使用 HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问 HTTP 请求。</li></ul><h1 id="Feign的特性"><a href="#Feign的特性" class="headerlink" title="Feign的特性"></a>Feign的特性</h1><ul><li>可插拔的注解支持，包括 Feign 注解和AX-RS注解。</li><li>支持可插拔的 HTTP 编码器和解码器。</li><li>支持 Hystrix 和它的 Fallback。</li><li>支持 Ribbon 的负载均衡</li><li>支持 HTTP 请求和响应的压缩。</li><li>整合了 Ribbon 和 Hystrix，从而不需要开发者针对 Feign 对其进行整合。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。<h1 id="FeignClient注解的一些属性"><a href="#FeignClient注解的一些属性" class="headerlink" title="@FeignClient注解的一些属性"></a>@FeignClient注解的一些属性</h1></li><li>Value:要调用的服务名称</li><li>url：url 一般用于调试，可以手动指定 @FeignClient 调用的地址。</li><li>decode404：当发生404错误时，如果该字段为 true，会调用 decoder 进行解码，否则抛出 FeignException。</li><li>configuration：Feign 配置类，可以自定义 Feign 的 Encoder、Decoder、LogLevel、Contract。</li><li>fallback：熔断机制，调用失败时，走的一些回退方法，可以用来抛出异常或给出默认返回数据，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，- fallback 指定的类必须实现 @FeignClient 标记的接口。</li><li>fallbackFactory：工厂类，用于生成 fallback 类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。</li><li>path：定义当前 FeignClient 的统一前缀,自动给所有方法的requestMapping前加上前缀，类似与controller类上的requestMapping</li></ul><h1 id="Feign原理简述"><a href="#Feign原理简述" class="headerlink" title="Feign原理简述"></a>Feign原理简述</h1><ul><li>启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。</li><li>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。</li><li>RequestTemplate生产Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。 </li><li>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。</li></ul><h1 id="RestTemplate-Ribbon与Feign对比"><a href="#RestTemplate-Ribbon与Feign对比" class="headerlink" title="RestTemplate + Ribbon与Feign对比"></a>RestTemplate + Ribbon与Feign对比</h1><ul><li>RestTemplate + Ribbon与Feign有很多相同的地方，但也有各自的差异，对比一下差异如下：<ul><li>角度    RestTemplate + Ribbon    Feign（自带Ribbon）</li><li>可读性、可维护性    欠佳（无法从URL直观了解这个远程调用是干什么的）    极佳（能在接口上写注解，方法名称也是可读的，能一眼看出这个远程调用是干什么的）</li><li>开发体验    欠佳（拼凑URL不性福）    极佳（写出漂亮的代码，女朋友更爱你了）</li><li>风格一致性    欠佳（本地API调用和RestTemplate调用的代码风格截然不同）    极佳（完全一致，不点开Feign的接口，根本不会察觉这是一个远程调用而非本地API调用）</li><li>性能    较好    中等（性能是RestTemplate的50%左右；如果为Feign配置连接池，性能可提升15%左右）</li><li>灵活性    极佳    中等（内置功能能满足大多数项目的需求）</li></ul></li></ul><h1 id="Feign的相关属性配置"><a href="#Feign的相关属性配置" class="headerlink" title="Feign的相关属性配置"></a>Feign的相关属性配置</h1><ul><li>目前，feign不支持GET请求直接传递POJO对象的，目前解决方法如下：<ul><li>把POJO拆散成一个一个单独的属性放在方法参数中</li><li>把方法参数组装成Map传递</li><li>使用GET传递@RequestBody，但此方式违反restful风格</li></ul></li><li>Spring Cloud Feign支持对请求和响应进行GZIP压缩，以提高通信效率。<br>由于开启GZIP压缩之后，Feign之间的调用数据通过二进制协议进行传输，返回值需要修改为ResponseEntity&lt;byte[]&gt;才可以正常显示，否则会导致服务之间的调用乱码。</li><li>作用在所有Feign Client上的两种配置方式：<ul><li>通过java bean的方式指定</li><li>通过配置文件直接配置<h1 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h1></li></ul></li><li>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</li><li>当服务I由于某种原因无法响应时，用户请求就会卡在服务 I 的远程调用上，假如超时失败时间设置为2秒，那么在这2秒内容器的当前线程就会一直被堵塞在该调用中。 我们假设容器最大线程数为100,如果此时又有另外99个请求都需要调用服务 I, 那么这99个线程同样会被堵塞，这样就会因为容器线程耗尽而导致该应用无法响应其它任何请求。因为一个服务挂掉而导致整个应用不可用显然是无法接受的。</li></ul><h1 id="Spring-Cloud中的Hystrix"><a href="#Spring-Cloud中的Hystrix" class="headerlink" title="Spring Cloud中的Hystrix"></a>Spring Cloud中的Hystrix</h1><ul><li>为了应对服务雪崩,一种常见的做法是手动服务降级。而Hystrix的出现,给我们提供了另一种选择。我们可以通过使用Hystrix来应对服务异常。</li><li>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。</li><li>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</li><li>断路打开后，可以避免连锁故障，fallback方法可以直接返回一个固定值。<h1 id="Spring-Cloud中的Hystrix实现断路器的原理"><a href="#Spring-Cloud中的Hystrix实现断路器的原理" class="headerlink" title="Spring Cloud中的Hystrix实现断路器的原理"></a>Spring Cloud中的Hystrix实现断路器的原理</h1></li><li>资源隔离：<ul><li>首先，Hystrix对每一个依赖服务都配置了一个线程池，对依赖服务的调用会在线程池中执行。例如，我们设计服务I的线程池大小为20,那么Hystrix会最多允许有20个容器线程调用服务I,如果超出20，Hystrix会拒绝并快速失败。这样即使服务I长时间未响应，容器最多也只能堵塞20个线程，剩余80个线程仍然可以处理用户请求。</li></ul></li><li>快速失败：<ul><li>快速失败是防止资源耗尽的关键一点。当Hystrix发现在过去某段时间内对服务I的调用出错率达到某个阀值时，Hystrix就会“熔断”该服务，后续任何向服务I的请求都会快速失败，而不是白白让调用线程去等待。</li></ul></li><li>自我修复：<ul><li>处于熔断状态的服务，在经过一段时间后，Hystrix会让其进入“半关闭”状态，即允许少量请求通过，然后统计调用的成功率。如果这个请求都能成功，Hystrix会恢复该服务，从而达到自我修复的效果。其中，在服务被熔断到进入半关闭状态之间的时间，就是留给开发人员排查错误并恢复故障的时间，开发人员可以通过监控措施得到提醒并线上排查。<h1 id="路由网关（zuul）简介"><a href="#路由网关（zuul）简介" class="headerlink" title="路由网关（zuul）简介"></a>路由网关（zuul）简介</h1></li></ul></li><li>Zuul是Netflix 公司开源的一个 API网关组件，提供了认证、鉴权、限流、动态路由、监控、 弹性、安全、负载均衡、协助单点压测、静态响应等边缘服务的框架 。</li><li>Zuul 处理每个请求的方式是针对每个请求使用一个线程来处理 通常情况下，为了提高性能， 所有请求会被放到处理队列中，从线程池中选取空闲线程来处理该请求。2016 年年底， Netflix将它们的网关服务zuul 进行了升级，全新的zuul2将HTTP 请求的处理方式从同步变成了异步，以 提升其处理性能</li><li>Zuul是Netflix出品的一个基于JVM 路由和服务端的负载均衡器<h1 id="为什么需要Spring-Cloud-Zuul"><a href="#为什么需要Spring-Cloud-Zuul" class="headerlink" title="为什么需要Spring Cloud Zuul"></a>为什么需要Spring Cloud Zuul</h1></li><li>Zuul和Ribbon以及Eureka相结合，可以实现智能路由和负载均衡的功能，可以将流量按照某种策略分发到集群中的多个实例。</li><li>统一了对外暴露接口，外界系统不需要知道微服务系统中各服务之间调用的复杂性，也保护了内部微服务的api接口。</li><li>可以统一做用户身份认证，权限验证，这样就不用在每个微服务中进行认证。</li><li>可以统一实现监控、日志的输出。</li><li>客户端请求多个微服务时，可以只请求Zuul一次，在Zuul中请求多个微服务，减少客户端和微服务的交互次数。<h1 id="路由网关（zuul）基本功能"><a href="#路由网关（zuul）基本功能" class="headerlink" title="路由网关（zuul）基本功能"></a>路由网关（zuul）基本功能</h1></li><li>Zuul的基本功能如如下：<ul><li>Authentication：认证</li><li>Insights：洞察</li><li>Stress Testing：压力测试</li><li>Canary Testing：金丝雀测试</li><li>Dynamic Routing：动态路由</li><li>Service Migration：服务迁移</li><li>Load Shedding：负载脱落</li><li>Security：安全</li><li>Static Response handling：静态响应处理</li><li>Active/Active traffic management：主动/主动流量管理</li></ul></li></ul><h1 id="功能概括"><a href="#功能概括" class="headerlink" title="功能概括"></a>功能概括</h1><ul><li>简要概括如下：<ul><li>验证与安全保障：识别面向各类资源的验证要求并拒绝那些与要求不符的请求。</li><li>审查与监控：在边缘位置追踪有意义的数据及统计结果，从而为用户带来准确的生产状态结论 。</li><li>动态路由：以动态方式根据需要将请求路由至不同后端集群处。</li><li>压力测试：逐渐增加指向集群的负载流量，从而计算性能水平 。     </li><li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 </li><li>静态响应处理 ：在边缘位置直接建立部分响应，从而避免其流入内部集群 。<h1 id="路由详解——传统路由的多实例配置"><a href="#路由详解——传统路由的多实例配置" class="headerlink" title="路由详解——传统路由的多实例配置"></a>路由详解——传统路由的多实例配置</h1></li></ul></li><li>请求进来的时候先去匹配path，然后用这个path的路由名去找对应的服务名，这里需要手动去命名服务名称，配合ribbon.listOfServers参数实现服务与实例的维护。由于存在多个实例，API网关在进行路由转发时需实现负载均衡，于是使用Ribbon的配合，Zuul中自带了对Ribbon的依赖。</li><li>参数说明：</li><li>ribbon.eureka.enabled：由于zuul.routes.&lt;路由名&gt;.serviceId用来指定服务名称，默认Ribbon会根据发现机制来获取配置服务名对应的实例清单，但是，这里没有使用Eureka之类的服务发现治理框架，所以需要将该参数设为false，否则配置的serviceId获取不到对应实例的清单</li><li>eureka-service.ribbon.listOfServers：该参数内容与zuul.routes.&lt;路由名&gt;的配置相对应，此配置打头的eureka-service对应了serviceId的值，相当于手动维护了在该应用内部手工维护了服务与实例的对应关系<h1 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h1></li><li>传统路由配置</li><li>传统路由就是不依赖于服务发现机制通过配置文件映射服务实例关系来实现的API网关对外请求路由。</li><li>面向服务路由</li><li>当有外部请求到达API网关的时候，根据请求的URL路径去匹配path的规则，通过path找到路由名，去找对应的serviceId的服务名</li><li>传统路由就会去根据这个服务名去找listOfServers参数，从而进行负载均衡和请求转发</li><li>面向服务路由会从注册到服务治理框架中取出服务实例清单，通过清单直接找到对应的实例地址清单，从而通过Ribbon进行负载均衡选取实例进行路由(请求转发)</li></ul><h1 id="SpringCloud动态路由的作用"><a href="#SpringCloud动态路由的作用" class="headerlink" title="SpringCloud动态路由的作用"></a>SpringCloud动态路由的作用</h1><ul><li>Spring Cloud 动态路由的作用是在微服务架构中实现灵活的路由管理和请求转发。</li><li>服务发现和负载均衡： 在微服务架构中，服务的数量可能非常庞大，并且会频繁地进行水平扩展或缩减。动态路由可以通过与服务注册中心结合，自动发现可用的服务实例，并提供负载均衡策略，确保请求能够均匀地分发到各个服务实例。</li><li>版本管理和灰度发布： 动态路由可以根据请求的特定条件（例如请求头、请求参数等）将请求导向不同的服务版本或者不同的处理逻辑。这样可以方便地进行版本管理和灰度发布，使得新版本的服务能够逐步接收流量，降低系统更新的风险。</li><li>动态配置和运维调整： 动态路由允许运维人员根据需要随时修改路由规则，而无需重启服务。这样可以方便地进行配置调整、故障切换、容错处理等运维操作。</li><li>微服务拆分和聚合： 动态路由可以根据请求的不同部分，将请求拆分成多个微服务的子请求，并将它们的结果聚合返回给客户端。这种方式可以帮助实现微服务的细粒度拆分和服务组合，提高系统的灵活性和性能。</li></ul><h1 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h1><ul><li>微服务应用中的每个客户端在提供服务的接口时，都会将访问权限加以限制，并不会放开所有的接口，为了安全，我们应该为每个微服务加入校验签名和鉴权等的过滤器或者拦截器，这样一来，会增加日后系统的维护难度，同时大部分的校验和鉴权的逻辑代码是相同的，那么我们就应该将这些重复逻辑提取出来，上文中曾说到“Zuul相当于整个微服务系统的门面”，那么接下来我们来看下在zuul网关中实现客户端的请求校验，即Spring Cloud Zuul 的核心功能之一的请求过滤。</li><li>我们先定义一个简单的Zuul过滤器，实现检查HttpServletRequest中是否有accessToken参数，如果有就进行路由，没有则拒绝访问，还回 401 Unauthorized 错误</li></ul><h1 id="服务过滤—ZuulFilter"><a href="#服务过滤—ZuulFilter" class="headerlink" title="服务过滤—ZuulFilter"></a>服务过滤—ZuulFilter</h1><ul><li>有以下四个方法：</li><li>filterType：在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<ul><li>pre：在请求被路由之前调用</li><li>route：路由请求时被调用</li><li>post：在routing和error过滤器之后被调用</li><li>error：处理请求时发生错误时被调用</li><li>路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址；而请求转发的部分则是由routing类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。</li></ul></li><li>filterOrder：通过int值来定义过滤器的执行顺序，如果有多个同类型过滤器，则按照值决定过滤顺序，数值越小优先级越高。 </li><li>shouldFilter：返回一个boolean值来判断该过滤器是否要执行，我们可以通过此方法来指定过滤器的有效范围。</li><li>run：过滤器的具体逻辑。在该函数中，我们可以实现自定义的过滤逻辑，来确定是否要拦截当前的请求，不对其进行后续的路由，或是在请求路由返回结果之后，对处理结果做一些加工等。</li></ul><h1 id="服务过滤—请求生命周期"><a href="#服务过滤—请求生命周期" class="headerlink" title="服务过滤—请求生命周期"></a>服务过滤—请求生命周期</h1><ul><li><p>外部http请求到达api网关服务的时候，首先它会进入第一个阶段pre，在这里它会被pre类型的过滤器进行处理。该类型过滤器的主要目的是在进行请求路由之前做一些前置加工，比如请求的校验等。</p></li><li><p>在完成了pre类型的过滤器处理之后，请求进入第二个阶段route，也就是之前说的路由请求转发阶段，请求将会被route类型的处理器处理。这里的具体处理内容就是将外部请求转发到具体服务实例上去的过程，当服务实例请求结果都返回之后，route阶段完成。</p></li><li><p>请求进入第三个阶段post。此时请求将会被post类型的过滤器处理，这些过滤器在处理的时候不仅可以获取到请求信息，还能获取到服务实例的返回信息，所以在post类型的过滤器中，我们可以对处理结果进行一些加工或转换等内容。</p></li><li><p>另外，还有一个特殊的阶段error，该阶段只有在上述三个阶段中发生异常的时候才会触发，但是它的最后流向还是post类型的过滤器，因为它需要通过post过滤器将最终结果返回给请求客户端（对于error过滤器的处理，在spring cloud zuul的过滤链中实际上有一些不同）</p></li><li><p>注意：同一个项目中，4种类型的过滤器可以同时存在，执行顺序是pre、routing、post、error</p><h1 id="服务过滤"><a href="#服务过滤" class="headerlink" title="服务过滤"></a>服务过滤</h1></li><li><p>在代码中，我们通过判断参数token的值来决定是否拦截请求。</p></li><li><p>先得到RequestContext对象ctx，通过ctx对象得到HttpServletRequest对象request。</p></li><li><p>再通过request.getParameter(“token”);得到token的值，</p></li><li><p>如果token值为null，则通过ctx 的setSendZuulResponse(false);方法设置拦截请求，即不能</p></li><li><p>通过过滤，此时我们通过HttpServletResponse对象转发到错误页面error.html。需要在static下新建error.html</p><h1 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h1></li><li><p>禁用过滤器，第一想到的是自定义的过滤器中shouldFilter返回false，实际应用中，这样还需要重新编译代码。</p></li><li><p>Zuul贴心地提供了一个参数用来禁用指定过滤器</p></li><li><p>zuul.&lt;过滤器名&gt;.&lt;过滤器类型&gt;.disable=true</p></li><li><p>如：前面我们写了一个MyFilter类，过滤类型为 pre </p></li><li><p>禁用此过滤器  pre不能改成其他类型，否则禁用失败，程序依然会过滤</p></li><li><p>zuul.MyFilter.pre.disable=true</p><h1 id="Cookie与头信息"><a href="#Cookie与头信息" class="headerlink" title="Cookie与头信息"></a>Cookie与头信息</h1></li><li><p>默认情况下，Zuul在请求路由时会过滤掉HTTP请求头信息中的一些敏感信息，防止这些敏感的头信息传递到下游外部服务器。但是如果我们使用安全框架如Spring Security、Apache Shiro等，需要使用Cookie做登录和鉴权，这时可以通过zuul.sensitiveHeaders参数定义，包括Cookie、Set-Cookie、Authorization三个属性来使Cookie可以被传递。</p></li><li><p>全局设置：zuul. sensitiveHeaders=Cookie,Set-Cookie,Authorization</p></li><li><p>指定路由设置：</p><ul><li>#指定路由名放行cookiezuul.routes.first.sensitiveHeaders= Cookie,Set-Cookie,Authorization<h1 id="ZuulFilter有哪些要重写的方法？"><a href="#ZuulFilter有哪些要重写的方法？" class="headerlink" title="ZuulFilter有哪些要重写的方法？"></a>ZuulFilter有哪些要重写的方法？</h1></li></ul></li><li><p>在使用 Zuul 进行服务网关开发时，通常需要继承 ZuulFilter 类，并实现其中的一些方法来扩展或定制 Zuul 的功能。下面是四个最重要的方法：</p></li><li><p>shouldFilter()： 该方法决定是否启用当前的 filter，返回 true 表示启用，false 则表示禁用。</p></li><li><p>run()： 该方法是实际执行过滤逻辑的地方。如果 shouldFilter() 方法返回 true，则会执行 run() 方法中的代码逻辑。</p></li><li><p>filterType()： 该方法决定当前 filter 的类型，包括 “pre”、”route”、”post”、”error” 四种类型。分别代表“路由之前”、“路由之时”、“路由之后”、“错误处理”这四个阶段。</p></li><li><p>filterOrder()： 该方法决定了 filter 的执行顺序。数值越小的 filter 会先执行。</p></li><li><p>通过重写这些方法，可以实现自定义的服务过滤逻辑，例如校验请求参数、添加请求头、限流、鉴权等功能。同时，也可以根据业务需求灵活调整 filter 的执行顺序，确保所有的 filter 能够按照正确的顺序依次执行</p></li></ul><h1 id="ZuulFilter过滤器类型有哪些？"><a href="#ZuulFilter过滤器类型有哪些？" class="headerlink" title="ZuulFilter过滤器类型有哪些？"></a>ZuulFilter过滤器类型有哪些？</h1><ul><li>PRE（路由之前）： 这种过滤器在请求被路由之前执行。可用于实现身份验证、参数校验、请求日志记录等功能。</li><li>ROUTE（路由之时）： 这种过滤器将请求路由到服务实例。用于构建发送给服务的请求，例如添加头信息、转换请求体等。</li><li>POST（路由之后）： 这种过滤器在路由到服务之后执行。可用于处理服务的响应，例如添加响应头、处理响应结果等。</li><li>ERROR（错误处理）： 在其他阶段发生错误时执行该过滤器。可用于统一处理路由过程中的异常情况，例如记录错误信息、返回特定格式的错误响应等。<h1 id="过滤器的执行顺序？"><a href="#过滤器的执行顺序？" class="headerlink" title="过滤器的执行顺序？"></a>过滤器的执行顺序？</h1></li><li>在 Zuul 中，过滤器的执行顺序由它们的 filterOrder() 方法返回的值来确定。数值越小的过滤器会先执行，而数值越大的过滤器会后执行。如果有多个过滤器在同一阶段，那么它们的执行顺序将根据它们的 filterOrder() 返回值的大小来确定。</li><li>通常情况下，开发者可以通过实现 filterOrder() 方法来指定过滤器的执行顺序，确保过滤器按照期望的顺序执行。例如，若希望某个过滤器在所有其他过滤器之前执行，则可以将它的 filterOrder() 返回一个较小的负数值。<h1 id="为什么需要集中化配置"><a href="#为什么需要集中化配置" class="headerlink" title="为什么需要集中化配置"></a>为什么需要集中化配置</h1></li><li>应用一般都会有配置文件，即便号称是“零配置”的 Spring Boot 应用，也无法完全做到不使 用配置文件 ，毕竟配置文件就是为了迎合软件的个性化需求 。一个带配置的应用程序，部署了多个 实例在若干台机器上，如果配置发生了变化，那么，就需要对该应用所有的实例进行配置的变更。     随着单块架构向微服务架构演进之后，微服务的应用数量也会剧增 。同时， 每个微服务都有自 己的配置文件，这些文件如果都散落在各自的应用中 ，必然会对应用的升级和配置管理带来挑战 毕竟谁也没有能力去手工配置那么多做服务的配置文件。 而且，对运维来说，一方面于工配置工作量很大，几乎不可能完成；另一方面， 相对而言，人为的操作会加大出错的几率。 所以，外部化 和中心化的配置中心， 变成了解决微服务配置问题的一个有力的途径。<h1 id="配置的分类"><a href="#配置的分类" class="headerlink" title="配置的分类"></a>配置的分类</h1></li><li>按配置的来源划分<ul><li>按配置的来源划分，主要有源代码、文件、数据库连接、远程调用等 。</li></ul></li><li>按适用的环境划分 <ul><li>按配置的适用环境划分，可分为开发环境、测试环境、预发布环境、生产环境等。 </li></ul></li><li>按配置的集成阶段划分 <ul><li>按配置的集成阶段划分，可分为编译时、打包时和运行时。编译时，最常见的有两种，一是源代码级的配置， 二是把配置文件和源代码一起提交到代码仓库中。打包时，即在应用打包阶段通过 某种方式将配置（一般是文件形式）打入最终的应用包中。运行时，是指应用启动前并不知道具体 的配置，而是在启动时，先从本地或远程获取配置，然后再正常启动。</li></ul></li><li>按配置的加载方式划分 <ul><li>按配置的加载方式划分，可分为启动加载和动态加载配置。</li><li>启动加载是指应用在启动时获取配置，并且只获取一次，在应用运行过程中不会再去加载。这类配置通常是不会经常变更的，如端口号、线程池大小等。</li><li>动态加载是指应用在运行过程中，随时都可以获取到的配置，这些配置意味着会在应用运行过程中经常被修改。<h1 id="配置中心的需求"><a href="#配置中心的需求" class="headerlink" title="配置中心的需求"></a>配置中心的需求</h1></li></ul></li><li>创建符合要求的、易于使用的配置中心，至少需要满足以下几个核心需求。</li><li>面向可配置的编码。编码过程中，应及早考虑将后期可能经常变更的数据，设置为可以配置的配置项，从而避免在代码里面硬编码。</li><li>隔离性。不同部署环境下，应用之间的配置是相互隔离的，例如，非生产环境的配置不能用于 生产环境。</li><li>一致性。相同部署环境下的服务器应用配置应该具有一致性， 即同个应用 的所有的实例使用同一份配置。</li><li>集中化配置。在分布式环境下，应用配置应该具备可管理性，即提供远程管理配置的能力。</li></ul><h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h1><ul><li>在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是服务器（config server），二是客户端（ config client ）。</li><li>Config Server存储后端的默认实现使用了Git ，因此它可以轻松地支持标记版本的配置环境， 并且可以通过广泛的工具来访问管理内容。<h1 id="搭建config-client项目时需要注意什么？"><a href="#搭建config-client项目时需要注意什么？" class="headerlink" title="搭建config-client项目时需要注意什么？"></a>搭建config-client项目时需要注意什么？</h1></li></ul><ol><li><p>要新建一个bootstrap.properties，这是由spring boot的加载属性文件的优先级决定的，你想要在加载属性之前去spring cloud config server上取配置文件，那spring cloud config相关配置就是需要最先加载的，而bootstrap.properties的加载是先于application.properties的，所以config client要配置config的相关配置就只能写到bootstrap.properties里。</p></li><li><p>spring.application.name要和配置文件的名称一致 ，如spring.application.name=config-client<br> spring.cloud.config.profile对应开发环境 ，如spring.cloud.config.profile=dev<br> 两者共同决定对应的配置文件，如以上配置对应config-client-dev.properties或<br>config-client-dev.yml</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Config server配置中心服务端，是从仓库拉取配置文件到项目中，供其它微服务项目调用。仓库配置有远程仓库（git）和本地仓库两种，推荐使用远程仓库。两种仓库同时配置时，项目将会选择本地仓库配置，而舍弃远程仓库配置。</li><li>Config Client是普通的微服务项目，从配置中心服务端拉取对应的配置文件。需要注意的是Config Client项目本身配置文件的加载顺序， bootstrap.properties的加载是先于application.properties的，所以config client要配置config的相关配置就只能写到bootstrap.properties里。</li><li>远程仓库如何配置？<ol><li>创建远程仓库： 在选择的代码托管服务上创建一个新的仓库。这个仓库将用来存储项目的代码。</li><li>获取远程仓库地址： 在仓库创建成功后，获取仓库的远程地址。这个地址通常是一个URL，可以通过HTTPS或SSH协议来访问。</li><li>配置本地仓库的远程地址： 在本地项目的根目录下，使用Git命令将远程仓库地址与本地仓库关联起来。通常使用 git remote add 命令进行配置。</li><li>推送代码到远程仓库： 将本地仓库中的代码推送（push）到远程仓库中。这样可以确保远程仓库和本地仓库的代码同步。</li></ol></li><li>如何直接通过url访问配置中心Config server从仓库加载到本地的配置文件？<ol><li>确定配置文件的URL： 在配置中心中，每个配置文件都有一个唯一的URL。这个URL通常由配置中心的基本URL以及配置文件的路径组成。</li><li>构建访问URL： 将配置中心的基本URL与配置文件的路径组合起来，构建完整的配置文件URL。</li><li>通过HTTP请求获取配置文件： 使用HTTP客户端（如浏览器、curl命令等）向构建好的URL发送GET请求，以获取配置文件内容。</li><li>解析配置文件内容： 获取到配置文件后，可以将其内容解析为适当的格式，如Properties文件、YAML文件等，以便在应用程序中使用。<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ol></li></ol><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养老院管理系统</title>
      <link href="/2024/01/20/blog/"/>
      <url>/2024/01/20/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>随着人口老龄化趋势的加剧，养老问题已经成为全球面临的重大社会问题之一。在中国，老年人口数量庞大，养老需求迅速增长，但养老服务水平和质量普遍存在不足，尤其是养老机构管理问题。当前，许多养老机构存在管理混乱、服务质量低下、人才短缺等问题，不能及时满足老年人的需求，给老年人的身体和心理健康带来了很大的困扰。</p><p>因此，建立一套高效的养老院管理系统是非常必要的。该系统可以实现对养老机构的信息化管理，包括老人入住、床位管理、医疗护理、膳食管理、活动安排、员工考勤、财务管理等方面。通过系统优化管理流程，提高服务质量，满足老年人的需求，保障老年人的权益和福利。</p><hr><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>系统的目标和用途：</strong></p><ul><li>我们开发的后台系统旨在提供一个高效、可靠且易于管理的解决方案，以支持各种业务需求。<br>它是一个基于云架构的后台管理平台，用于管理和监控用户数据、处理业务逻辑以及支持关键决策。</li></ul><p><strong>系统的主要功能和特点：</strong></p><ul><li>我们的后台系统具备多个核心功能，包括用户管理、权限控制、数据存储与处理、业务逻辑实现、报表生成等。<br>它提供了一个直观友好的用户界面，使用户能够轻松地管理、操作和监控系统中的数据和业务流程。</li></ul><p><strong>系统采用的技术架构：</strong></p><ul><li>我们的后台系统采用了现代化的技术架构，使用了流行的编程语言和开发框架，如 <code>javaWeb语言</code>和 <code>SpingMvc框架</code>。<br>数据库方面，我们选择了高性能和可扩展的关系型数据库 <code>MySQL</code>。<br>系统的架构设计注重可扩展性、灵活性和高性能，以满足不断增长的用户需求。</li></ul><p><strong>各个模块和功能的介绍：</strong></p><ul><li>后台系统由多个模块组成，每个模块都承担着不同的功能。比如,用户管理模块用于管理用户信息和权限控制，<br>数据存储与处理模块负责数据的存储、处理和分析，业务逻辑实现模块用于实现具体的业务流程，报表生成模块能够生成丰富的报表和图表,订单管理模块用于管理物品或药品的采购,入库,领用等等。可以帮助管理员更好地管理和处理订单业务流程，提高订单处理效率和精度。同时，该模块还提供了丰富的报表和统计功能，以帮助管理员对订单数据进行分析和决策等。这些模块之间通过API进行交互，形成一个完整的后台系统。  </li></ul><p><strong>数据管理的方法和策略：</strong></p><ul><li>我们的后台系统采用了严格的数据管理方法和策略，确保数据的完整性和可靠性。<br>数据以结构化的方式存储在数据库中，并进行定  期备份和冗余存储。同时，我们也注重数据安全性，采取了多层次的访问控制和加密措施，以保护用户数据的安全。</li></ul><p><strong>性能优化措施：</strong></p><ul><li>为了提高系统的性能和响应速度，我们采取了多项性能优化措施。例如，对数据库查询进行优化，使用缓存技术加速数据访问，<br>优化代码以减少资源消耗等。这些措施使得系统能够处理大规模数据和高并发请求，保证系统的高效率和稳定性。</li></ul><p><strong>用户界面设计：</strong></p><ul><li>后台系统的用户界面经过精心设计，注重用户体验和易用性。它采用直观的布局和交互方式，<br>使用户能够快速上手并轻松完成各种 操作。用户界面提供了丰富的功能和操作方式，如数据查看、编辑、导出等，以满足不同用户的需求。</li></ul><p><strong>测试和部署：</strong></p><ul><li>为了保证系统的质量和稳定性，我们采用了全面的测试策略。包括单元测试、集成测试、自动化测试等多种测试方法，<br>以确保系统 在各种场景下都能正常运行。在部署方面，我们使用容器化技术和自动化部署流程，实现快速、可靠的系统部署。</li></ul><p><strong>成果和效益：</strong></p><ul><li>我们的后台系统已经取得了显著的成果和效益。通过提供高效的数据管理和业务流程支持，<br>我们帮助用户提升了工作效率，降低了成本，改进了决策过程。</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 养老院管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingMvc </tag>
            
            <tag> ElementUi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro</title>
      <link href="/2024/01/20/shiro/"/>
      <url>/2024/01/20/shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro实现权限控制步骤"><a href="#Shiro实现权限控制步骤" class="headerlink" title="Shiro实现权限控制步骤"></a>Shiro实现权限控制步骤</h1><p>   1.加入3个依赖<br>       shiro-core（shiro内核依赖）<br>       shiro-spring(shiro与spring整合依赖)<br>       spring-boot-starter-aop(spring aop依赖)<br>   2.创建shiro对应的配置文件<br>      1.ShiroConfig(文件名称可以自定义，配置类),自动加载，并执行shiroFilter方法，排除不需要权限的URL<br>          同时启动注解功能（即运行authorizationAttributeSourceAdvisor方法）<br>          该类启动时执行一次，后面不再执行该类<br>      2.UserRealm(文件名称可以自定义，实现用户登录与权限控制)<br>   3.在需要进行权限控制的方法前面加上对应的注解<br>      @RequiresPermissions(“权限字符串”)<br>      当访问路径对应的方法前面有@RequiresPermissions注解时，系统自动调用UserRealm类的AuthorizationInfo方法进行权限验证，<br>      如果有权限那么程序正常执行，如果没有权限，系统会自动抛出异常,UserExceptionHandler类会自动处理异常<br>   4.创建全局异常处理类<br>      UserExceptionHandler:当用户点击没有权限的菜单（按钮）时，进行统一的异常处理，并返回错误信息<br>   5.对应5个表<br>      User表:用户表<br>      Role表：角色表<br>      user_role表:用户角色表<br>      permission表:系统权限表<br>      role_permission表:角色权限表</p><h1 id="设置不需要进行权限控制的路径-允许匿名访问"><a href="#设置不需要进行权限控制的路径-允许匿名访问" class="headerlink" title="设置不需要进行权限控制的路径(允许匿名访问)"></a>设置不需要进行权限控制的路径(允许匿名访问)</h1><pre><code>anon:允许匿名访问authc：需要进行身份认证的路径map.put("/login2/", "anon"); // 登录成功后的访问路径map.put("/login2/login", "anon"); // 登录操作map.put("/js/**", "anon"); // js文件路径map.put("/css/**", "anon"); // css文件路径map.put("/images/**", "anon"); // 图标文件路径map.put("/upload/**", "anon"); // 上传后的图片访问路径（MyMvcConfig类中配置的路径）map.put("/**", "authc"); // 进行身份认证后才能访问</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2024/01/20/vue2/"/>
      <url>/2024/01/20/vue2/</url>
      
        <content type="html"><![CDATA[<h1 id="vue封装数据发送后台"><a href="#vue封装数据发送后台" class="headerlink" title="vue封装数据发送后台"></a>vue封装数据发送后台</h1><pre><code>可以使用将数据转换为JSON格式或者使用FormData对象封装数据(键值对)键对应后台的实体类,值前端要传入后台的值    JSON:                             const data = {                     name: 'John',                    age: 25,                        };    JSON.stringify(data)    FormData:    const formData = new FormData();    formData.append('name', 'John');    formData.append('age', 25);</code></pre><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>1.创建一个表单并添加一个文件输入控件，例如使用<code>&lt;input type="file"&gt;</code>元素。<br>2.监听文件选择事件，获取用户选择的文件，并将其存储在Vue组件的data属性中。<br>3.通过FormData（表单数据对象）来构造包含上传文件的表单数据。<br>4.发送POST请求到服务器，携带表单数据，以此来完成文件上传操作。<br>后端，我们使用了Spring Boot框架和Spring MVC来处理文件上传。通过@RequestParam注解来获取上传的文件，MultipartFile对象包含了文件的各种信息和操作方法。我们使用getBytes()方法获取文件的字节数组，然后使用Files.write()方法将文件写入目标路径。</p><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p>1.<code>beforeCreate</code>：实例刚被创建，数据观测和事件配置之前，此时无法访问到data和methods等实例属性。<br>2.<code>created</code>：实例已经被创建，数据观测和事件配置完成，此时可以访问到data和methods等实例属性，但未挂载到DOM上。<br>3.<code>beforeMount</code>：在挂载开始之前被调用，此时模板编译已完成，但DOM还未生成。<br>4.<code>mounted</code>：实例已经挂载到DOM上，此时可以对DOM进行操作，访问到挂载的元素。<br>5.<code>beforeUpdate</code>：数据更新时，重新渲染之前被调用，此时数据已经更新，但DOM尚未重新渲染。<br>6.<code>updated</code>：数据更新并且DOM重新渲染完成后被调用。<br>7.<code>beforeDestroy</code>：实例销毁之前被调用，此时实例仍然完全可用。<br>8.<code>destroyed</code>：实例销毁后被调用，此时实例及其所有的事件监听器和观察者都被移除。<br>9.<code>beforeCreate</code>和<code>created</code>钩子函数会在组件实例化之前执行；<br>10.<code>beforeDestroy</code>和<code>destroyed</code>钩子函数会在组件销毁之前执行。</p><h1 id="vue权限控制"><a href="#vue权限控制" class="headerlink" title="vue权限控制"></a>vue权限控制</h1><p>当我们开发一个应用程序时，经常需要对用户的权限进行控制，以决定用户能够执行哪些操作或看到哪些内容。<br>首先，我们需要在Vue中注册这个自定义指令。指令是一种特殊的功能，可以在HTML标签中使用，用来控制元素的行为。在这个例子中，我们将指令名称设置为<code>permission</code>。<br>接下来，我们定义了指令的具体实现逻辑。当一个元素被插入到页面中时，指令会生效。在这个函数中，我们首先从浏览器的存储中（<code>sessionStorage</code>）获取用户的权限列表，这个列表中存储了用户拥有的权限信息。<br>然后，我们判断当前权限列表中是否包含了指令的绑定值（也就是所需的权限）。如果不包含，说明用户没有相应的权限。在这种情况下，我们会进行以下操作：<br>如果元素不是按钮，我们会将它隐藏起来，使用户无法看到它。<br>如果元素是按钮，我们会禁用它，使用户无法点击它。<br>此外，我们还给禁用的按钮添加了一个CSS类名<code>is-disabled</code>，通过添加这个类名，我们可以为禁用的按钮添加一些特定的样式。<br>最后，代码中还添加了一个自定义方法<code>contains</code>，用来判断一个数组是否包含某个特定的值。尽管在这段代码中没有使用到这个方法，但可能会在其他地方使用到它。<br>总的来说，这段代码实现了一个功能权限判断的指令。它通过用户的权限列表来控制应用程序中的元素是否可见或可操作，从而实现了权限控制的功能。</p><h1 id="spingmvc的一些注解"><a href="#spingmvc的一些注解" class="headerlink" title="spingmvc的一些注解"></a>spingmvc的一些注解</h1><p>1.@Controller：用于标识一个类为Spring MVC的控制器，可以处理HTTP请求并返回响应结果。<br>2.@RequestMapping：用于映射请求路径和控制器方法，支持路径变量、请求参数和HTTP方法等条件。<br>3.@PathVariable：用于获取URL中的路径变量，可以将其绑定到方法参数中。<br>4.@RequestParam：用于获取请求参数，可以将其绑定到方法参数中，并支持参数默认值、必填项和名称映射等配置。<br>5.@ResponseBody：用于标识方法返回的结果直接写入HTTP响应体中，而不是通过模板引擎渲染页面。<br>6.@ModelAttribute：用于在请求处理方法执行前将请求参数绑定到模型对象中，以便在视图中进行显示。<br>7.@SessionAttribute：用于将模型对象存储到会话中，以便多个请求之间共享数据。<br>8.@CookieValue：用于获取指定名称的cookie值，并将其绑定到方法参数中。<br>9.@InitBinder：用于定制数据绑定操作，例如对日期格式进行转换、防止XSS攻击等。<br>10.@ExceptionHandler：用于捕获控制器内部抛出的异常，并进行统一处理和返回错误信息。</p><h1 id="spingmvc返回数据到前端的几种方式"><a href="#spingmvc返回数据到前端的几种方式" class="headerlink" title="spingmvc返回数据到前端的几种方式"></a>spingmvc返回数据到前端的几种方式</h1><p>1.使用@ResponseBody注解：在控制器的方法上添加@ResponseBody注解，可以将方法的返回值直接写入HTTP响应体中。Spring MVC会自动将返回值转换为JSON、XML等格式，并设置正确的Content-Type头。<br>2.返回ModelAndView对象：ModelAndView是Spring MVC中常用的返回类型，它包含了要返回给视图的数据和视图名称。<br>3.使用Model和Map：可以在方法参数中添加Model或Map类型的参数，然后将数据存储到其中。Spring MVC会自动将这些数据传递给视图。<br>4.使用HttpServletRequest和HttpServletResponse：可以直接在方法参数中声明HttpServletRequest和HttpServletResponse对象，并使用它们进行数据读取和写入。</p><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
