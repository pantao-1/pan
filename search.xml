<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shiro</title>
      <link href="/2024/03/04/shiro/"/>
      <url>/2024/03/04/shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="shiro实现权限控制步骤"><a href="#shiro实现权限控制步骤" class="headerlink" title="shiro实现权限控制步骤"></a>shiro实现权限控制步骤</h1><p>   1.加入3个依赖<br>       shiro-core（shiro内核依赖）<br>        shiro-spring(shiro与spring整合依赖)<br>        spring-boot-starter-aop(spring aop依赖)<br>   2.创建shiro对应的配置文件<br>      1.ShiroConfig(文件名称可以自定义，配置类),自动加载，并执行shiroFilter方法，排除不需要权限的URL<br>          同时启动注解功能（即运行authorizationAttributeSourceAdvisor方法）<br>          该类启动时执行一次，后面不再执行该类<br>      2.UserRealm(文件名称可以自定义，实现用户登录与权限控制)<br>   3.在需要进行权限控制的方法前面加上对应的注解<br>      @RequiresPermissions(“权限字符串”)<br>      当访问路径对应的方法前面有@RequiresPermissions注解时，系统自动调用UserRealm类的AuthorizationInfo方法进行权限验证，<br>      如果有权限那么程序正常执行，如果没有权限，系统会自动抛出异常,UserExceptionHandler类会自动处理异常<br>   4.创建全局异常处理类<br>      UserExceptionHandler:当用户点击没有权限的菜单（按钮）时，进行统一的异常处理，并返回错误信息<br>   5.对应5个表<br>      User表:用户表<br>      Role表：角色表<br>      user_role表:用户角色表<br>      permission表:系统权限表<br>      role_permission表:角色权限表</p><h1 id="设置不需要进行权限控制的路径-允许匿名访问"><a href="#设置不需要进行权限控制的路径-允许匿名访问" class="headerlink" title="设置不需要进行权限控制的路径(允许匿名访问)"></a>设置不需要进行权限控制的路径(允许匿名访问)</h1><pre><code>anon:允许匿名访问authc：需要进行身份认证的路径map.put("/login2/", "anon"); // 登录成功后的访问路径map.put("/login2/login", "anon"); // 登录操作map.put("/js/**", "anon"); // js文件路径map.put("/css/**", "anon"); // css文件路径map.put("/images/**", "anon"); // 图标文件路径map.put("/upload/**", "anon"); // 上传后的图片访问路径（MyMvcConfig类中配置的路径）map.put("/**", "authc"); // 进行身份认证后才能访问</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpingBoot</title>
      <link href="/2024/02/23/spingboot/"/>
      <url>/2024/02/23/spingboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpingBoot"><a href="#SpingBoot" class="headerlink" title="SpingBoot"></a>SpingBoot</h1><h1 id="创建项目步骤"><a href="#创建项目步骤" class="headerlink" title="创建项目步骤"></a>创建项目步骤</h1><ul><li>创建项目步骤：(必须确保网络能正常访问)<br> 1.File-&gt;new -&gt;module<br> 2.选择spring initializr<br> 3.配置项：<pre><code> 1.group name(默认包) 2.name(发布包的名称) 3.type(maven项目） 4.packaging(打包方式，jar,war)</code></pre> 4.选择需要的依赖，选中的依赖会自动配置到pom.xml文件中，也可以手动配置<br> 5.修改pom.xml文件<pre><code> 1.修改jdk版本为本机环境对应的版本 2.修改打包方式 3.添加需要的依赖 4.配置web路径，资源路径</code></pre> 6.启动项目（找到BootdemoApplication类） </li></ul><hr><h1 id="SpingBoot整合mybatis"><a href="#SpingBoot整合mybatis" class="headerlink" title="SpingBoot整合mybatis"></a>SpingBoot整合mybatis</h1><ul><li>修改pom.xml<br>1.添加Mybatis和Mysql依赖 <!--Spring Boot Mybatis 依赖 --><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt;</code></pre>2.修改application.properties<pre><code>SpringBoot配置数据源spring.datasource.driver-class-name= com.mysql.jdbc.Driverspring.datasource.url= jdbc:mysql://192.168.0.188:3306/boot?useUnicode=truecharacterEncoding=utf8&amp;  useSSL=falsespring.datasource.username= rootspring.datasource.password= 11111111</code></pre>3.配置扫描实体类和配置扫描 映射文件        <pre><code>mybatis-plus.type-aliases-package=com.example.luo.entitymybatis-plus.mapper-locations=classpath*:/mapper/*.xml</code></pre>4.配置扫描 dao<pre><code> 只需要在 SpringBoot启动 main方法中添加注解 @MapperScan 扫描Dao 组件 //配置mybatis dao所在的包 @MapperScan("com.lgr.bootdemo1.dao") //启动类注解，包含main方法的类要添加该注解，作为程序的入口 @SpringBootApplication public class Bootdemo1Application {     public static void main(String[] args) {         SpringApplication.run(Bootdemo1Application.class, args);     } }</code></pre>5.创建数据库表<br>6.创建实体类<br> 注意:实体类路基需和第三步配置的包路径一致。<br>7.创建dao接口<br> 注意:dao接口需和第四步创建的包路径下<br>8.创建dao接口映射文件(.xml编写简便的sql语句)<br> 注意:接口映射文件必须配置在第三步配置路径下<br>9.在项目的test文件夹下项目包里有一个测试类<br> 导入实体类如：<pre><code> @Autowired BatchDAO batchDAO;</code></pre> 编写测试类,选中运行<pre><code>  @Test void contextLoads() { BatchVo batchVo = new BatchVo(); batchVo.setBatchId(0); batchVo.setBatchName("2024暑假社会实践"); batchVo.setState(1); batchVo.setRemark(""); batchDAO.insert(batchVo); }</code></pre></li></ul><hr><h1 id="SpringBoot-整合-SpringMVC"><a href="#SpringBoot-整合-SpringMVC" class="headerlink" title="SpringBoot 整合 SpringMVC"></a>SpringBoot 整合 SpringMVC</h1><pre><code>  1.在pom文件中添加  &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  -----------------------------------------------------------  spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包  此 starter pom 内嵌tomcat、servlet、SpringMVC 依赖。  启动后会默认启动tomcat 占用8080端口  没有加此依赖SpringBoot 不能启动 tomcat容器。  -----------------------------------------------------------  spring-boot-starter-web 所做的事  自动配置内嵌Servlet 容器 tomcat  自动配置http编码 utf-8  自动配置SpringMVC  自动配置文件上传(文件上传大小限制)  ------------------------------------------------------------  添加完spring-boot-starter-web 依赖 就可以使用SpringMVC的注解  @Controller 表示这是一个控制层bean  @RequestMapping  处理请求地址映射注解  @GetMapping  使用get 方式处理请求地址映射注解  @PostMapping  使用post 方式处理请求地址映射注解  @ResponseBody  设置JSON格式响应  注意：此时没有配置视图页面，只能显示html页面，不能解析JSP或者thymeleaf 等模板引擎。        添加@ResponseBody 注解可以返回JSON格式数据</code></pre><p>  SpringBoot 返回JSON数据<br>  创建IndexController(控制器)<br>  注意：IndexController 一定要创建在SpringBoot 启动main方法同级，或者下级，不然扫描不到Controller<br>  使用方法：和SpringMVC 没有区别<br>  项目启动：和普通的web项目启动不同，在SpringBoot中，启动web项目也是启动main方法，和普通的java项目没有区别！<br>  访问：<a href="http://localhost:8080/getMapJSON" target="_blank" rel="noopener">http://localhost:8080/getMapJSON</a> 得到json数据。</p><pre><code>  @GetMapping("/json")  @ResponseBody  public  Map json(){      Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();          map.put("值1","1");          map.put("值2","2");      return map;  }</code></pre><h1 id="SpringBoot-整合-JSP"><a href="#SpringBoot-整合-JSP" class="headerlink" title="SpringBoot 整合 JSP"></a>SpringBoot 整合 JSP</h1><pre><code>修改pom.xml添加依赖，修改打包信息修改application.properties 配置文件添加webapp文件夹，添加WEB-INF文件夹修改idea web项目配置修改Controller添加jsp页面</code></pre><p>1.修改pom.xml 增加依赖</p><pre><code>&lt;!-- jsp支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;  &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jstl标签库 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2.修改pom.xml修改项目打包设置</p><pre><code>      &lt;build&gt;       &lt;plugins&gt;       &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;!-- 默认版本和SpringBoot版本一致，            使用高版本的打包方式，不能正确打包。 --&gt;        &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;       &lt;/plugin&gt;       &lt;/plugins&gt;      &lt;resources&gt;      &lt;!-- 打包时将jsp文件拷贝到META-INF目录下--&gt;      &lt;resource&gt;        &lt;!-- 指定处理哪个目录下的资源文件 --&gt;        &lt;directory&gt;${basedir}/src/main/webapp&lt;/directory&gt;        &lt;!--注意此次必须要放在此目录下才能被访问到--&gt;        &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;  &lt;/resources&gt;&lt;/build&gt;</code></pre><p>3.修改application.properties 配置文件</p><pre><code>spring.mvc.view.suffix=.jspspring.mvc.view.prefix=/WEB-INF/jsp/</code></pre><p>4.添加webapp文件夹</p><pre><code>1、在src --&gt; main 下添加webapp文件夹2、在webapp下添加WEB-INF文件夹3、在WEB-INF下添加jsp文件夹4、在jsp文件夹下添加hello.jsp5、配置idea指定WEB目录</code></pre><hr><h1 id="控制器传递数据的六种方式"><a href="#控制器传递数据的六种方式" class="headerlink" title="控制器传递数据的六种方式"></a>控制器传递数据的六种方式</h1><pre><code>1.Map   @GetMapping("/map")   public String getMap(Map map){    map.put("msg1","map对象返回的值");    return "test";   }2.Model      @GetMapping("/model")public String getModel(Model model){    model.addAttribute("msg2","Model对象返回的值");    return "test";}3.ModelMap      @GetMapping("/modelMap")public String getModelMap(ModelMap model){    model.addAttribute("msg3","ModelMap对象返回的值");    return "test";}4.ModelAndView   @GetMapping("/modelAndView")public ModelAndView getModelMap(){    ModelAndView mv = new ModelAndView();    //设置返回值    mv.addObject("msg4","ModelAndView对象返回的值");    //设置页面名称    mv.setViewName("test");    return mv;}5.servlet的返回方式   @GetMapping("/request")    public String getRequest(HttpServletRequest request, HttpServletResponse response){    //设置返回值    request.setAttribute("msg5","request对象返回的值");    return "test";}6.返回JSON格式数据需要使用@ResponseBody注解@GetMapping("/json")@ResponseBodypublic BatchVo getJson(){    BatchVo batchVo = new BatchVo();    batchVo.setBatchId(0);    batchVo.setBatchName("2024暑假社会实践");    batchVo.setState(1);    batchVo.setRemark("");    return batchVo;}</code></pre><hr><h1 id="控制器接收前端数据的六种方式"><a href="#控制器接收前端数据的六种方式" class="headerlink" title="控制器接收前端数据的六种方式"></a>控制器接收前端数据的六种方式</h1><p> 方法一:</p><pre><code>  前端：      function login(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.post(           '/login/login',            {                'userName': user,                'password':pass            },            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：      //jquery的post方法提交数据      @PostMapping("/login")      @ResponseBody      public UserVo login(UserVo userVo){          System.out.println(userVo);          return userVo;      }</code></pre><p>方法二:</p><pre><code>  前端：        function login1(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login1?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：          //jquery的get方法提交数据          @GetMapping("/login1")          //login/login1?userName=张三&amp;password=1234          //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换          @ResponseBody          public UserVo login1(@RequestParam("userName") String name,@RequestParam("password") String pass){              UserVo userVo = new UserVo();              userVo.setUserName(name);              userVo.setPassword(pass);              System.out.println(userVo);              return userVo;          }</code></pre><p>方法三:</p><pre><code>  前端：      function login2(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login2?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：        //jquery的get方法提交数据        @GetMapping("/login2")        //login/login2?userName=张三&amp;password=1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login2(String userName,String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法四:</p><pre><code>  前端：     function login3(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login3/' + user + '/' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：         //jquery的get方法提交数据        @GetMapping("/login3/{userName}/{password}")        //login/login3/张三/1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login3(@PathVariable("userName") String userName,@PathVariable("password") String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法五:</p><pre><code>  前端：    function login4(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        return true;    }    控制器：            @PostMapping("/login4")      public String login4(UserVo userVo){          System.out.println(userVo);          return "index";      }        //接收表单提交数据(效果与login4一样)    @PostMapping("/login5")    public String login5(HttpServletRequest request, HttpServletResponse response){        UserVo userVo = new UserVo();        userVo.setUserName(request.getParameter("userName"));        userVo.setPassword(request.getParameter("password"));        System.out.println(userVo);        return "index";    }</code></pre><h1 id="SpringBoot整合使用druid连接池"><a href="#SpringBoot整合使用druid连接池" class="headerlink" title="SpringBoot整合使用druid连接池"></a>SpringBoot整合使用druid连接池</h1><p> 1.添加MybatisPlusConfig类</p><pre><code>   //启动事务   @EnableTransactionManagement        /*            配置文件            使用了@Configuration注解的类就是配置类，程序启动时系统会自动执行，            该注解的作用就是把以往的xml文件转换为java类            @Bean注解，就是配置一个bean，相当于mvc项目中的xml配置文件中bean        */        @Configuration        public class MybatisPlusConfig {            /**            * 分页插件,创建一个分页的拦截器            */            @Bean            public PaginationInterceptor paginationInterceptor() {                return  new PaginationInterceptor();            }        }</code></pre><p>  2.添加以下依赖</p><pre><code>&lt;!-- mysql驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.48&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis-plus --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--druid连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>  3.添加配置</p><pre><code>#所有参数的配置，冒号后面必须有一个空格        #配置tomcat的端口        server:        port: 8888        servlet:            #项目访问路径            context-path: /            #session的有效期为30分钟，m分钟，s秒            session:            timeout: 30m        #数据源配置        spring:        datasource:            driver-class-name: com.mysql.jdbc.Driver            url: jdbc:mysql://localhost:3306/boot?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true            username: root            password: 11111111            druid:            #配置监控url            stat-view-servlet:                #连接池的监控地址                url-pattern: /druid/*                #登录名                login-username: root                #登录密码                login-password: 123456                enabled: true            #初始值            initial-size: 10            #最大连接数            max-active: 100            #最小连接数            min-idle: 10            #最大等待时间            max-wait: 60000            pool-prepared-statements: true            max-pool-prepared-statement-per-connection-size: 20            time-between-eviction-runs-millis: 60000            min-evictable-idle-time-millis: 300000            #validation-query: SELECT 1 FROM DUAL            validation-query: SELECT 1 'X'            test-while-idle: true            test-on-borrow: false            test-on-return: false            filters: stat,wall,slf4j        mvc:            #配置jsp文件存放的根路径            view:            #后缀            suffix: .jsp            #前缀            prefix: /WEB-INF/jsp/        http:            #设置字符编码            encoding:            charset: UTF-8#mybatis配置(dao在启动类用@MapperScan注解配置)mybatis-plus:#mybatis的映射文件路径，放在resources的子文件夹内mapper-locations: classpath:mapper/*.xml#配置别名，javabean的包路径type-aliases-package: com.lgr.bootdemo1.entityglobal-config:    #数据库相关配置    db-config:    #主键类型  AUTO:"数据库ID自增", INPUT:"用户输入ID", ID_WORKER:"全局唯一ID (数字类型唯一ID)", UUID:"全局唯一ID UUID";    id-type: AUTO    #字段策略 IGNORED:"忽略判断",NOT_NULL:"非 NULL 判断"),NOT_EMPTY:"非空判断"    field-strategy: NOT_NULL    #驼峰下划线转换    column-underline: true    #逻辑已删除值(默认为 1)    logic-delete-value: 1    #逻辑未删除值(默认为 0)    logic-not-delete-value: 0    banner: falseconfiguration:    # 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射    map-underscore-to-camel-case: true    cache-enabled: false    call-setters-on-nulls: true    jdbc-type-for-null: 'null'    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>3.添加dao包新建BatchDAO类继承bean(extends BaseMapper<batchvo>) 添加service包下面添加impl包<br>4.service添加BatchServiceDAO类继承bean(extends IService<batchvo>)<br>5.impl包添加BatchServiceDaoImpl继承service包下面的BatchServiceDAO类(implements BatchServiceDAO )<br>6.BatchServiceDaoImpl引入dao</batchvo></batchvo></p><pre><code>@AutowiredBatchDAO batchDAO;</code></pre><p>7.右键生成方法注意添加启动事务@Transactional(查询操作外)<br>比如无条件查询表</p><pre><code>@Overridepublic List&lt;User&gt; list() {    return userDao.selectList(null);}</code></pre><p>8.添加控制器引入</p><pre><code>@Autowiredprivate UserServiceDao userServiceDao;实现方法 @RequestMapping("/list")public List&lt;User&gt; getEricUserList(){    return userServiceDao.list();}页面通过项目ip/druid/访问监控页面</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpingBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingBoot </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECharts</title>
      <link href="/2024/01/22/echarts/"/>
      <url>/2024/01/22/echarts/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ECharts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvm工具</title>
      <link href="/2024/01/22/nvm/"/>
      <url>/2024/01/22/nvm/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养老院管理系统</title>
      <link href="/2024/01/20/blog/"/>
      <url>/2024/01/20/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>随着人口老龄化趋势的加剧，养老问题已经成为全球面临的重大社会问题之一。在中国，老年人口数量庞大，养老需求迅速增长，但养老服务水平和质量普遍存在不足，尤其是养老机构管理问题。当前，许多养老机构存在管理混乱、服务质量低下、人才短缺等问题，不能及时满足老年人的需求，给老年人的身体和心理健康带来了很大的困扰。</p><p>因此，建立一套高效的养老院管理系统是非常必要的。该系统可以实现对养老机构的信息化管理，包括老人入住、床位管理、医疗护理、膳食管理、活动安排、员工考勤、财务管理等方面。通过系统优化管理流程，提高服务质量，满足老年人的需求，保障老年人的权益和福利。</p><hr><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>系统的目标和用途：</strong></p><ul><li>我们开发的后台系统旨在提供一个高效、可靠且易于管理的解决方案，以支持各种业务需求。<br>它是一个基于云架构的后台管理平台，用于管理和监控用户数据、处理业务逻辑以及支持关键决策。</li></ul><p><strong>系统的主要功能和特点：</strong></p><ul><li>我们的后台系统具备多个核心功能，包括用户管理、权限控制、数据存储与处理、业务逻辑实现、报表生成等。<br>它提供了一个直观友好的用户界面，使用户能够轻松地管理、操作和监控系统中的数据和业务流程。</li></ul><p><strong>系统采用的技术架构：</strong></p><ul><li>我们的后台系统采用了现代化的技术架构，使用了流行的编程语言和开发框架，如 <code>javaWeb语言</code>和 <code>SpingMvc框架</code>。<br>数据库方面，我们选择了高性能和可扩展的关系型数据库 <code>MySQL</code>。<br>系统的架构设计注重可扩展性、灵活性和高性能，以满足不断增长的用户需求。</li></ul><p><strong>各个模块和功能的介绍：</strong></p><ul><li>后台系统由多个模块组成，每个模块都承担着不同的功能。比如,用户管理模块用于管理用户信息和权限控制，<br>数据存储与处理模块负责数据的存储、处理和分析，业务逻辑实现模块用于实现具体的业务流程，报表生成模块能够生成丰富的报表和图表,订单管理模块用于管理物品或药品的采购,入库,领用等等。可以帮助管理员更好地管理和处理订单业务流程，提高订单处理效率和精度。同时，该模块还提供了丰富的报表和统计功能，以帮助管理员对订单数据进行分析和决策等。这些模块之间通过API进行交互，形成一个完整的后台系统。  </li></ul><p><strong>数据管理的方法和策略：</strong></p><ul><li>我们的后台系统采用了严格的数据管理方法和策略，确保数据的完整性和可靠性。<br>数据以结构化的方式存储在数据库中，并进行定  期备份和冗余存储。同时，我们也注重数据安全性，采取了多层次的访问控制和加密措施，以保护用户数据的安全。</li></ul><p><strong>性能优化措施：</strong></p><ul><li>为了提高系统的性能和响应速度，我们采取了多项性能优化措施。例如，对数据库查询进行优化，使用缓存技术加速数据访问，<br>优化代码以减少资源消耗等。这些措施使得系统能够处理大规模数据和高并发请求，保证系统的高效率和稳定性。</li></ul><p><strong>用户界面设计：</strong></p><ul><li>后台系统的用户界面经过精心设计，注重用户体验和易用性。它采用直观的布局和交互方式，<br>使用户能够快速上手并轻松完成各种 操作。用户界面提供了丰富的功能和操作方式，如数据查看、编辑、导出等，以满足不同用户的需求。</li></ul><p><strong>测试和部署：</strong></p><ul><li>为了保证系统的质量和稳定性，我们采用了全面的测试策略。包括单元测试、集成测试、自动化测试等多种测试方法，<br>以确保系统 在各种场景下都能正常运行。在部署方面，我们使用容器化技术和自动化部署流程，实现快速、可靠的系统部署。</li></ul><p><strong>成果和效益：</strong></p><ul><li>我们的后台系统已经取得了显著的成果和效益。通过提供高效的数据管理和业务流程支持，<br>我们帮助用户提升了工作效率，降低了成本，改进了决策过程。</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 养老院管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingMvc </tag>
            
            <tag> ElementUi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2024/01/20/blog-open-source/"/>
      <url>/2024/01/20/blog-open-source/</url>
      
        <content type="html"><![CDATA[<h1 id="vue封装数据发送后台"><a href="#vue封装数据发送后台" class="headerlink" title="vue封装数据发送后台"></a>vue封装数据发送后台</h1><pre><code>可以使用将数据转换为JSON格式或者使用FormData对象封装数据(键值对)键对应后台的实体类,值前端要传入后台的值    JSON:                             const data = {                     name: 'John',                    age: 25,                        };    JSON.stringify(data)    FormData:    const formData = new FormData();    formData.append('name', 'John');    formData.append('age', 25);</code></pre><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>1.创建一个表单并添加一个文件输入控件，例如使用<code>&lt;input type="file"&gt;</code>元素。<br>2.监听文件选择事件，获取用户选择的文件，并将其存储在Vue组件的data属性中。<br>3.通过FormData（表单数据对象）来构造包含上传文件的表单数据。<br>4.发送POST请求到服务器，携带表单数据，以此来完成文件上传操作。<br>后端，我们使用了Spring Boot框架和Spring MVC来处理文件上传。通过@RequestParam注解来获取上传的文件，MultipartFile对象包含了文件的各种信息和操作方法。我们使用getBytes()方法获取文件的字节数组，然后使用Files.write()方法将文件写入目标路径。</p><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p>1.<code>beforeCreate</code>：实例刚被创建，数据观测和事件配置之前，此时无法访问到data和methods等实例属性。<br>2.<code>created</code>：实例已经被创建，数据观测和事件配置完成，此时可以访问到data和methods等实例属性，但未挂载到DOM上。<br>3.<code>beforeMount</code>：在挂载开始之前被调用，此时模板编译已完成，但DOM还未生成。<br>4.<code>mounted</code>：实例已经挂载到DOM上，此时可以对DOM进行操作，访问到挂载的元素。<br>5.<code>beforeUpdate</code>：数据更新时，重新渲染之前被调用，此时数据已经更新，但DOM尚未重新渲染。<br>6.<code>updated</code>：数据更新并且DOM重新渲染完成后被调用。<br>7.<code>beforeDestroy</code>：实例销毁之前被调用，此时实例仍然完全可用。<br>8.<code>destroyed</code>：实例销毁后被调用，此时实例及其所有的事件监听器和观察者都被移除。<br>9.<code>beforeCreate</code>和<code>created</code>钩子函数会在组件实例化之前执行；<br>10.<code>beforeDestroy</code>和<code>destroyed</code>钩子函数会在组件销毁之前执行。</p><h1 id="vue权限控制"><a href="#vue权限控制" class="headerlink" title="vue权限控制"></a>vue权限控制</h1><p>当我们开发一个应用程序时，经常需要对用户的权限进行控制，以决定用户能够执行哪些操作或看到哪些内容。<br>首先，我们需要在Vue中注册这个自定义指令。指令是一种特殊的功能，可以在HTML标签中使用，用来控制元素的行为。在这个例子中，我们将指令名称设置为<code>permission</code>。<br>接下来，我们定义了指令的具体实现逻辑。当一个元素被插入到页面中时，指令会生效。在这个函数中，我们首先从浏览器的存储中（<code>sessionStorage</code>）获取用户的权限列表，这个列表中存储了用户拥有的权限信息。<br>然后，我们判断当前权限列表中是否包含了指令的绑定值（也就是所需的权限）。如果不包含，说明用户没有相应的权限。在这种情况下，我们会进行以下操作：<br>如果元素不是按钮，我们会将它隐藏起来，使用户无法看到它。<br>如果元素是按钮，我们会禁用它，使用户无法点击它。<br>此外，我们还给禁用的按钮添加了一个CSS类名<code>is-disabled</code>，通过添加这个类名，我们可以为禁用的按钮添加一些特定的样式。<br>最后，代码中还添加了一个自定义方法<code>contains</code>，用来判断一个数组是否包含某个特定的值。尽管在这段代码中没有使用到这个方法，但可能会在其他地方使用到它。<br>总的来说，这段代码实现了一个功能权限判断的指令。它通过用户的权限列表来控制应用程序中的元素是否可见或可操作，从而实现了权限控制的功能。</p><h1 id="spingmvc的一些注解"><a href="#spingmvc的一些注解" class="headerlink" title="spingmvc的一些注解"></a>spingmvc的一些注解</h1><p>1.@Controller：用于标识一个类为Spring MVC的控制器，可以处理HTTP请求并返回响应结果。<br>2.@RequestMapping：用于映射请求路径和控制器方法，支持路径变量、请求参数和HTTP方法等条件。<br>3.@PathVariable：用于获取URL中的路径变量，可以将其绑定到方法参数中。<br>4.@RequestParam：用于获取请求参数，可以将其绑定到方法参数中，并支持参数默认值、必填项和名称映射等配置。<br>5.@ResponseBody：用于标识方法返回的结果直接写入HTTP响应体中，而不是通过模板引擎渲染页面。<br>6.@ModelAttribute：用于在请求处理方法执行前将请求参数绑定到模型对象中，以便在视图中进行显示。<br>7.@SessionAttribute：用于将模型对象存储到会话中，以便多个请求之间共享数据。<br>8.@CookieValue：用于获取指定名称的cookie值，并将其绑定到方法参数中。<br>9.@InitBinder：用于定制数据绑定操作，例如对日期格式进行转换、防止XSS攻击等。<br>10.@ExceptionHandler：用于捕获控制器内部抛出的异常，并进行统一处理和返回错误信息。</p><h1 id="spingmvc返回数据到前端的几种方式"><a href="#spingmvc返回数据到前端的几种方式" class="headerlink" title="spingmvc返回数据到前端的几种方式"></a>spingmvc返回数据到前端的几种方式</h1><p>1.使用@ResponseBody注解：在控制器的方法上添加@ResponseBody注解，可以将方法的返回值直接写入HTTP响应体中。Spring MVC会自动将返回值转换为JSON、XML等格式，并设置正确的Content-Type头。<br>2.返回ModelAndView对象：ModelAndView是Spring MVC中常用的返回类型，它包含了要返回给视图的数据和视图名称。<br>3.使用Model和Map：可以在方法参数中添加Model或Map类型的参数，然后将数据存储到其中。Spring MVC会自动将这些数据传递给视图。<br>4.使用HttpServletRequest和HttpServletResponse：可以直接在方法参数中声明HttpServletRequest和HttpServletResponse对象，并使用它们进行数据读取和写入。</p><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
