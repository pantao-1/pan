<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis</title>
      <link href="/2024/03/15/redis/"/>
      <url>/2024/03/15/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><pre><code>——关系型数据库    关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。 包含Mysql、Oracle、SqlServer等。随着互联网WEB2.0时代的到来，面临着高并发、高性能的一系列的挑战。——非关系型数据库    新型的数据库模型，也被称为NOSQL数据库，NOSQL本意是“NOT ONLY SQL”，并不是彻底要彻底否定关系型数据库，而是作为传统关系型数据库的一个有效补充。包含 memcached （纯内存），redis（持久化缓存），mongodb（文档的数据库） </code></pre><hr><h1 id="非关系型数据库的分类"><a href="#非关系型数据库的分类" class="headerlink" title="非关系型数据库的分类"></a>非关系型数据库的分类</h1><pre><code>1、key-value存储数据库   键值数据库就类似传统语言中使用哈希表，可以通过key来添加、查询或删除数据，因为使用key主键访问，所以会获得很高的性能及扩展性 。典型产品：Memcached、Redis、MemcacheDB、BerkeleyDB 2、列存储（Column-oriedted）数据库  了解即可，一般公司用不到，典型产品：Cassandra,HBase 3、面向文档（Document-Oriented）数据库  面向文档数据库会将数据以文档的形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。典型产品：MorgoDB、CouchDB 4、图形（Graph）数据库</code></pre><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><pre><code>Window下安装：下载地址：https://github.com/MSOpenTech/redis/releases选择64位的ZIP压缩包点击下载，下载完成后解压，并将解压后的文件夹重命名为redis，方便后面使用</code></pre><h1 id="运行Redis服务"><a href="#运行Redis服务" class="headerlink" title="运行Redis服务"></a>运行Redis服务</h1><pre><code>1、使用cmd命令行进入解压后的redis目录2、在redis目录下 运行redis-server redis.windows.conf，启动redis服务，此时当关闭命令窗口redis服务也会关闭，其中后面的redis.window.conf可以省略将Redis配成windows服务3、可以将redis服务安装成windows服务，在redis目录下的命令窗口输入：redis-server --service-install redis.windows.conf即可4、查看服务是否配置成功，右键计算机—管理—服务，查找是否有Redis服务，如果启动，代表windows上的redis服务已经配置成功，redis服务已经启动。</code></pre><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><pre><code>启动本机Redis客户端：redis–cli ，此命令连接到本机的Redis服务，同时用PING命令检测本机Redis服务是否启动连接远程Redis服务： redis–cli –h host –p port –a “password”其中host为远程主机IP地址Port为远程Redis服务端口号Password为远程Redis服务密码用客户端连接了redis服务之后，就可以在当前命令行里使用redis命令来操作redis数据库了</code></pre><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><pre><code>1.Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(有序集合)。2.String（字符串）（最常用）string是redis最基本的类型，是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。3.Hash（哈希）（常用）Redis hash 是一个键值(key=&gt;value)对集合。Redis hash 是一个 string 类型的 key和 value 的映射表，hash 特别适合用于存储对象，相当于java中的Map集合。4.List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。5.Set（集合）Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。6.zset(sorted set：有序集合)（了解）Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</code></pre><h1 id="Redis键命令"><a href="#Redis键命令" class="headerlink" title="Redis键命令"></a>Redis键命令</h1><pre><code>SET keyname value     新建一个键值对，keyname为键名，value为存储的值DEL keyname     删除一个已存在的key，keyname为键名，成功返回1，失败返回0EXISTS keyname    判断一个key是否存在，keyname为键名，RENAME key newkey    重命名一个已存在的key，key为原来的键名，newkey为新键名EXPIRE key seconds    给一个已存在的key设置过期时间，key为键名，seconds为秒数PERSIST keyname    移除key的过期时间，key将永久保持，keyname为键名TTL keyname    以毫秒数返回key的剩余时间，keyname为键名RANDOMKEY     从当前数据库随机返回一个key</code></pre><h1 id="Redis字符串命令"><a href="#Redis字符串命令" class="headerlink" title="Redis字符串命令"></a>Redis字符串命令</h1><pre><code>SET keyname value    设置一个键值对，keyname为键名，value为存储的值GET keyname    获取指定key对应的值，keyname为键名GETSET keyname value    将指定key的值设为value，同时返回该key原来的旧值MGET key1 key2…..    获取所有给定key的值GETRANGE key start end    获取指定key里的截取字符串，start为起始位置，end为结束位置STRLEN keyname    获取指定key里存储字符串的长度INCR keyname    给指定key里存储的数字增1APPEND keyname value    给指定key里存储的字符串末尾追加value</code></pre><h1 id="Redis哈希（hash）命令"><a href="#Redis哈希（hash）命令" class="headerlink" title="Redis哈希（hash）命令"></a>Redis哈希（hash）命令</h1><pre><code>HMSET key field1 “value1”…    同时将多个 field-value (域-值)对设置到哈希表 key 中HDEL key field1 field2…..    删除指定key哈希表的一个或者多个字段，key为哈希表的键，field1为哈希表里的字段名HEXISTS key field    查看指定key的哈希表内是否存在field字段HGET key field    获取指定key的哈希表内的field字段存储的值HGETALL key    获取指定key的哈希表的所有字段和值HKEYS key    获取指定key的哈希表中所有的字段HMGET key field1 field2…    获取指定key的哈希表中所有指定字段的值HVALS key    获取指定key的哈希表中所有的值</code></pre><h1 id="Redis列表（List）命令"><a href="#Redis列表（List）命令" class="headerlink" title="Redis列表（List）命令"></a>Redis列表（List）命令</h1><pre><code>LPUSH key value1 value2…    同时将一个或多个值插入到列表头部，设定的key即为列表的键LPUSH key value1 value2…    同时将一个或多个值插入到已存在的key对应的列表头部LPOP key    移出并获取指定key的列表中的第一个元素LINDEX key index    通过索引获取指定key的列表中的元素，index从0开始LRANGE key start stop    通过索引获取指定key的列表中某个范围的元素RPOP key    移出并获取指定key的列表中最后一个元素LREM key count value    移出指定key的列表中，与value相等的元素 count&gt;0 从表头开始搜索；count&lt;0 从表尾开始搜索；count=0 移出所有与value相等的元素LTRIM key start stop    截取指定key的列表中的部分元素</code></pre><h1 id="Redis集合（Set）命令"><a href="#Redis集合（Set）命令" class="headerlink" title="Redis集合（Set）命令"></a>Redis集合（Set）命令</h1><pre><code>SADD key m1 m2…    向集合添加一个或多个成员SCARD key    获取指定key对应的集合内的成员数SINTER key1 key2    获取所有给定集合的交集SISMEMBER key member    判断member元素是否是集合key的成员SMEMBERS key    返回集合中的所有成员SPOP key    返回并移出集合中的一个随机元素SREM key member1 member2    移除集合中一个或多个成员</code></pre><h1 id="Redis缓存特性"><a href="#Redis缓存特性" class="headerlink" title="Redis缓存特性"></a>Redis缓存特性</h1><pre><code>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s ，而关系型数据库MYSQL读写速度仅为2000次/s左右。丰富的数据类型 – Redis支持二进制安全的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。原子 性– Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。丰富的特性 – Redis还支持 publish/subscribe通知订阅模式, key 过期等等特性。</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpingBoot</title>
      <link href="/2024/02/23/spingboot/"/>
      <url>/2024/02/23/spingboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpingBoot"><a href="#SpingBoot" class="headerlink" title="SpingBoot"></a>SpingBoot</h1><h1 id="创建项目步骤"><a href="#创建项目步骤" class="headerlink" title="创建项目步骤"></a>创建项目步骤</h1><ul><li>创建项目步骤：(必须确保网络能正常访问)<br> 1.File-&gt;new -&gt;module<br> 2.选择spring initializr<br> 3.配置项：<pre><code> 1.group name(默认包) 2.name(发布包的名称) 3.type(maven项目） 4.packaging(打包方式，jar,war)</code></pre> 4.选择需要的依赖，选中的依赖会自动配置到pom.xml文件中，也可以手动配置<br> 5.修改pom.xml文件<pre><code> 1.修改jdk版本为本机环境对应的版本 2.修改打包方式 3.添加需要的依赖 4.配置web路径，资源路径</code></pre> 6.启动项目（找到BootdemoApplication类） </li></ul><hr><h1 id="SpingBoot整合mybatis"><a href="#SpingBoot整合mybatis" class="headerlink" title="SpingBoot整合mybatis"></a>SpingBoot整合mybatis</h1><ul><li>修改pom.xml<br>1.添加Mybatis和Mysql依赖 <!--Spring Boot Mybatis 依赖 --><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt;</code></pre>2.修改application.properties<pre><code>SpringBoot配置数据源spring.datasource.driver-class-name= com.mysql.jdbc.Driverspring.datasource.url= jdbc:mysql://192.168.0.188:3306/boot?useUnicode=truecharacterEncoding=utf8&amp;  useSSL=falsespring.datasource.username= rootspring.datasource.password= 11111111</code></pre>3.配置扫描实体类和配置扫描 映射文件        <pre><code>mybatis-plus.type-aliases-package=com.example.luo.entitymybatis-plus.mapper-locations=classpath*:/mapper/*.xml</code></pre>4.配置扫描 dao<pre><code> 只需要在 SpringBoot启动 main方法中添加注解 @MapperScan 扫描Dao 组件 //配置mybatis dao所在的包 @MapperScan("com.lgr.bootdemo1.dao") //启动类注解，包含main方法的类要添加该注解，作为程序的入口 @SpringBootApplication public class Bootdemo1Application {     public static void main(String[] args) {         SpringApplication.run(Bootdemo1Application.class, args);     } }</code></pre>5.创建数据库表<br>6.创建实体类<br> 注意:实体类路基需和第三步配置的包路径一致。<br>7.创建dao接口<br> 注意:dao接口需和第四步创建的包路径下<br>8.创建dao接口映射文件(.xml编写简便的sql语句)<br> 注意:接口映射文件必须配置在第三步配置路径下<br>9.在项目的test文件夹下项目包里有一个测试类<br> 导入实体类如：<pre><code> @Autowired BatchDAO batchDAO;</code></pre> 编写测试类,选中运行<pre><code>  @Test void contextLoads() { BatchVo batchVo = new BatchVo(); batchVo.setBatchId(0); batchVo.setBatchName("2024暑假社会实践"); batchVo.setState(1); batchVo.setRemark(""); batchDAO.insert(batchVo); }</code></pre></li></ul><hr><h1 id="SpringBoot-整合-SpringMVC"><a href="#SpringBoot-整合-SpringMVC" class="headerlink" title="SpringBoot 整合 SpringMVC"></a>SpringBoot 整合 SpringMVC</h1><pre><code>  1.在pom文件中添加  &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  -----------------------------------------------------------  spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包  此 starter pom 内嵌tomcat、servlet、SpringMVC 依赖。  启动后会默认启动tomcat 占用8080端口  没有加此依赖SpringBoot 不能启动 tomcat容器。  -----------------------------------------------------------  spring-boot-starter-web 所做的事  自动配置内嵌Servlet 容器 tomcat  自动配置http编码 utf-8  自动配置SpringMVC  自动配置文件上传(文件上传大小限制)  ------------------------------------------------------------  添加完spring-boot-starter-web 依赖 就可以使用SpringMVC的注解  @Controller 表示这是一个控制层bean  @RequestMapping  处理请求地址映射注解  @GetMapping  使用get 方式处理请求地址映射注解  @PostMapping  使用post 方式处理请求地址映射注解  @ResponseBody  设置JSON格式响应  注意：此时没有配置视图页面，只能显示html页面，不能解析JSP或者thymeleaf 等模板引擎。        添加@ResponseBody 注解可以返回JSON格式数据</code></pre><p>  SpringBoot 返回JSON数据<br>  创建IndexController(控制器)<br>  注意：IndexController 一定要创建在SpringBoot 启动main方法同级，或者下级，不然扫描不到Controller<br>  使用方法：和SpringMVC 没有区别<br>  项目启动：和普通的web项目启动不同，在SpringBoot中，启动web项目也是启动main方法，和普通的java项目没有区别！<br>  访问：<a href="http://localhost:8080/getMapJSON" target="_blank" rel="noopener">http://localhost:8080/getMapJSON</a> 得到json数据。</p><pre><code>  @GetMapping("/json")  @ResponseBody  public  Map json(){      Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();          map.put("值1","1");          map.put("值2","2");      return map;  }</code></pre><h1 id="SpringBoot-整合-JSP"><a href="#SpringBoot-整合-JSP" class="headerlink" title="SpringBoot 整合 JSP"></a>SpringBoot 整合 JSP</h1><pre><code>修改pom.xml添加依赖，修改打包信息修改application.properties 配置文件添加webapp文件夹，添加WEB-INF文件夹修改idea web项目配置修改Controller添加jsp页面</code></pre><p>1.修改pom.xml 增加依赖</p><pre><code>&lt;!-- jsp支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;  &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jstl标签库 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2.修改pom.xml修改项目打包设置</p><pre><code>      &lt;build&gt;       &lt;plugins&gt;       &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;!-- 默认版本和SpringBoot版本一致，            使用高版本的打包方式，不能正确打包。 --&gt;        &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;       &lt;/plugin&gt;       &lt;/plugins&gt;      &lt;resources&gt;      &lt;!-- 打包时将jsp文件拷贝到META-INF目录下--&gt;      &lt;resource&gt;        &lt;!-- 指定处理哪个目录下的资源文件 --&gt;        &lt;directory&gt;${basedir}/src/main/webapp&lt;/directory&gt;        &lt;!--注意此次必须要放在此目录下才能被访问到--&gt;        &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;            &lt;include&gt;**/**&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;  &lt;/resources&gt;&lt;/build&gt;</code></pre><p>3.修改application.properties 配置文件</p><pre><code>spring.mvc.view.suffix=.jspspring.mvc.view.prefix=/WEB-INF/jsp/</code></pre><p>4.添加webapp文件夹</p><pre><code>1、在src --&gt; main 下添加webapp文件夹2、在webapp下添加WEB-INF文件夹3、在WEB-INF下添加jsp文件夹4、在jsp文件夹下添加hello.jsp5、配置idea指定WEB目录</code></pre><hr><h1 id="控制器传递数据的六种方式"><a href="#控制器传递数据的六种方式" class="headerlink" title="控制器传递数据的六种方式"></a>控制器传递数据的六种方式</h1><pre><code>1.Map   @GetMapping("/map")   public String getMap(Map map){    map.put("msg1","map对象返回的值");    return "test";   }2.Model      @GetMapping("/model")public String getModel(Model model){    model.addAttribute("msg2","Model对象返回的值");    return "test";}3.ModelMap      @GetMapping("/modelMap")public String getModelMap(ModelMap model){    model.addAttribute("msg3","ModelMap对象返回的值");    return "test";}4.ModelAndView   @GetMapping("/modelAndView")public ModelAndView getModelMap(){    ModelAndView mv = new ModelAndView();    //设置返回值    mv.addObject("msg4","ModelAndView对象返回的值");    //设置页面名称    mv.setViewName("test");    return mv;}5.servlet的返回方式   @GetMapping("/request")    public String getRequest(HttpServletRequest request, HttpServletResponse response){    //设置返回值    request.setAttribute("msg5","request对象返回的值");    return "test";}6.返回JSON格式数据需要使用@ResponseBody注解@GetMapping("/json")@ResponseBodypublic BatchVo getJson(){    BatchVo batchVo = new BatchVo();    batchVo.setBatchId(0);    batchVo.setBatchName("2024暑假社会实践");    batchVo.setState(1);    batchVo.setRemark("");    return batchVo;}</code></pre><hr><h1 id="控制器接收前端数据的六种方式"><a href="#控制器接收前端数据的六种方式" class="headerlink" title="控制器接收前端数据的六种方式"></a>控制器接收前端数据的六种方式</h1><p> 方法一:</p><pre><code>  前端：      function login(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.post(           '/login/login',            {                'userName': user,                'password':pass            },            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：      //jquery的post方法提交数据      @PostMapping("/login")      @ResponseBody      public UserVo login(UserVo userVo){          System.out.println(userVo);          return userVo;      }</code></pre><p>方法二:</p><pre><code>  前端：        function login1(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login1?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：          //jquery的get方法提交数据          @GetMapping("/login1")          //login/login1?userName=张三&amp;password=1234          //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换          @ResponseBody          public UserVo login1(@RequestParam("userName") String name,@RequestParam("password") String pass){              UserVo userVo = new UserVo();              userVo.setUserName(name);              userVo.setPassword(pass);              System.out.println(userVo);              return userVo;          }</code></pre><p>方法三:</p><pre><code>  前端：      function login2(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login2?userName=' + user + '&amp;password=' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：        //jquery的get方法提交数据        @GetMapping("/login2")        //login/login2?userName=张三&amp;password=1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login2(String userName,String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法四:</p><pre><code>  前端：     function login3(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        //使用jquery的post方法提交数据        $.get(            '/login/login3/' + user + '/' + pass,            //回调函数,接收后端返回的值,data变量就是后端返回的值            function(data){                alert(data.userName);            }        );        return true;    }    控制器：         //jquery的get方法提交数据        @GetMapping("/login3/{userName}/{password}")        //login/login3/张三/1234        //使用@RequestParam注解接收参数,表单返回的变量与控制器的变量名称不一致时，可以转换        @ResponseBody        public UserVo login3(@PathVariable("userName") String userName,@PathVariable("password") String password){            UserVo userVo = new UserVo();            userVo.setUserName(userName);            userVo.setPassword(password);            System.out.println(userVo);            return userVo;        }</code></pre><p>方法五:</p><pre><code>  前端：    function login4(){        var user = $("#userName").val();        var pass = $("#password").val();        if(user==""){            alert("请输入用户名称");            //设置焦点            $("#userName").focus();            return false;        }        if(pass==""){            alert("密码不能为空");            //设置焦点            $("#password").focus();            return false;        }        return true;    }    控制器：            @PostMapping("/login4")      public String login4(UserVo userVo){          System.out.println(userVo);          return "index";      }        //接收表单提交数据(效果与login4一样)    @PostMapping("/login5")    public String login5(HttpServletRequest request, HttpServletResponse response){        UserVo userVo = new UserVo();        userVo.setUserName(request.getParameter("userName"));        userVo.setPassword(request.getParameter("password"));        System.out.println(userVo);        return "index";    }</code></pre><h1 id="SpringBoot整合使用druid连接池"><a href="#SpringBoot整合使用druid连接池" class="headerlink" title="SpringBoot整合使用druid连接池"></a>SpringBoot整合使用druid连接池</h1><p> 1.添加MybatisPlusConfig类</p><pre><code>   //启动事务   @EnableTransactionManagement        /*            配置文件            使用了@Configuration注解的类就是配置类，程序启动时系统会自动执行，            该注解的作用就是把以往的xml文件转换为java类            @Bean注解，就是配置一个bean，相当于mvc项目中的xml配置文件中bean        */        @Configuration        public class MybatisPlusConfig {            /**            * 分页插件,创建一个分页的拦截器            */            @Bean            public PaginationInterceptor paginationInterceptor() {                return  new PaginationInterceptor();            }        }</code></pre><p>  2.添加以下依赖</p><pre><code>&lt;!-- mysql驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.48&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis-plus --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--druid连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.20&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>  3.添加配置</p><pre><code>#所有参数的配置，冒号后面必须有一个空格        #配置tomcat的端口        server:        port: 8888        servlet:            #项目访问路径            context-path: /            #session的有效期为30分钟，m分钟，s秒            session:            timeout: 30m        #数据源配置        spring:        datasource:            driver-class-name: com.mysql.jdbc.Driver            url: jdbc:mysql://localhost:3306/boot?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true            username: root            password: 11111111            druid:            #配置监控url            stat-view-servlet:                #连接池的监控地址                url-pattern: /druid/*                #登录名                login-username: root                #登录密码                login-password: 123456                enabled: true            #初始值            initial-size: 10            #最大连接数            max-active: 100            #最小连接数            min-idle: 10            #最大等待时间            max-wait: 60000            pool-prepared-statements: true            max-pool-prepared-statement-per-connection-size: 20            time-between-eviction-runs-millis: 60000            min-evictable-idle-time-millis: 300000            #validation-query: SELECT 1 FROM DUAL            validation-query: SELECT 1 'X'            test-while-idle: true            test-on-borrow: false            test-on-return: false            filters: stat,wall,slf4j        mvc:            #配置jsp文件存放的根路径            view:            #后缀            suffix: .jsp            #前缀            prefix: /WEB-INF/jsp/        http:            #设置字符编码            encoding:            charset: UTF-8#mybatis配置(dao在启动类用@MapperScan注解配置)mybatis-plus:#mybatis的映射文件路径，放在resources的子文件夹内mapper-locations: classpath:mapper/*.xml#配置别名，javabean的包路径type-aliases-package: com.lgr.bootdemo1.entityglobal-config:    #数据库相关配置    db-config:    #主键类型  AUTO:"数据库ID自增", INPUT:"用户输入ID", ID_WORKER:"全局唯一ID (数字类型唯一ID)", UUID:"全局唯一ID UUID";    id-type: AUTO    #字段策略 IGNORED:"忽略判断",NOT_NULL:"非 NULL 判断"),NOT_EMPTY:"非空判断"    field-strategy: NOT_NULL    #驼峰下划线转换    column-underline: true    #逻辑已删除值(默认为 1)    logic-delete-value: 1    #逻辑未删除值(默认为 0)    logic-not-delete-value: 0    banner: falseconfiguration:    # 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射    map-underscore-to-camel-case: true    cache-enabled: false    call-setters-on-nulls: true    jdbc-type-for-null: 'null'    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>3.添加dao包新建BatchDAO类继承bean(extends BaseMapper<batchvo>) 添加service包下面添加impl包<br>4.service添加BatchServiceDAO类继承bean(extends IService<batchvo>)<br>5.impl包添加BatchServiceDaoImpl继承service包下面的BatchServiceDAO类(implements BatchServiceDAO )<br>6.BatchServiceDaoImpl引入dao</batchvo></batchvo></p><pre><code>@AutowiredBatchDAO batchDAO;</code></pre><p>7.右键生成方法注意添加启动事务@Transactional(查询操作外)<br>比如无条件查询表</p><pre><code>@Overridepublic List&lt;User&gt; list() {    return userDao.selectList(null);}</code></pre><p>8.添加控制器引入</p><pre><code>@Autowiredprivate UserServiceDao userServiceDao;实现方法 @RequestMapping("/list")public List&lt;User&gt; getEricUserList(){    return userServiceDao.list();}页面通过项目ip/druid/访问监控页面</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpingBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingBoot </tag>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECharts</title>
      <link href="/2024/01/22/echarts/"/>
      <url>/2024/01/22/echarts/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ECharts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECharts </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvm工具</title>
      <link href="/2024/01/22/nvm/"/>
      <url>/2024/01/22/nvm/</url>
      
        <content type="html"><![CDATA[<h1 id="ECharts"><a href="#ECharts" class="headerlink" title="ECharts"></a>ECharts</h1><p><strong>如何使用Echarts：</strong></p><ul><li>①获取Echarts ：在官网下载Echarts版本 或 npm下载 </li><li>②引入Echarts ：script引入 或者 vue在入口文件里引用 </li><li>③创建一个dom元素 用来放置图表 </li><li>④配置Echarts属性  </li></ul><p><strong>Echarts和vue如何从后台数据库获取数据：</strong></p><ul><li>这里介绍两种<br>1.柱状图 2.饼图<br>1.柱状图如图所示分为x轴和y轴,因为我们表查询不止这两个字段所以后端返回数据前端进行封装,可以使用<br>循环列表获取x轴和y轴需要显示的数据保存到新数组修改<table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot面试题</title>
      <link href="/2024/01/22/springboot/"/>
      <url>/2024/01/22/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h1><ol><li>什么是SpringBoot？</li></ol><ul><li>SpringBoot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，<br>提供了各种启动器，开发者可以快速上手。</li></ul><ol start="2"><li>为什么要使用SpringBoot？</li></ol><ul><li>快速开发</li><li>快速整合第三方框架（Maven依赖关系，Maven继承）</li><li>简化XML的配置</li><li>内置嵌入HTTP服务器（Tomcat（默认）、Jetty），降低了对环境的要求</li></ul><ol start="3"><li>SpringBoot的优点？</li></ol><ul><li>容易上手，提升开发效率，为Spring开发提供一个更快、更简单的开发框架</li><li>远离繁琐的配置</li><li>提供一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li></ul><ol start="4"><li>SpringBoot的缺点</li></ol><ul><li>SpringBoot仅适用于全新Spring项目。将一个传统SpringFramework项目转换为SpringBoot应用程序是一个非常困难和耗时的过程</li><li>集成度较高，使用过程中不太容易了解底层</li></ul><ol start="5"><li>SpringBoot与SpringCloud区别</li></ol><ul><li>SpringBoot是快速开发的Spring框架，而SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot进行开发。</li></ul><ol start="6"><li>Spring 和SpringBoot有何不同？    </li></ol><ul><li>SpringBoot本质上是Spring框架的延伸和扩展，它的诞生是为了简化Spring框架初始搭建以及开发过程，使用它可以不再依赖Spring应用程序中的XML配置，为更快、更高效的开发Spring提供更加有力的支持。</li><li>更快速的构建能力：SpringBoot提供了更多的Starters用于快速构建业务框架，Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找依赖包</li><li>起步依赖：在创建SpringBoot时可以直接勾选依赖模块，这样在项目初始化时就会把相关依赖直接添加到项目中，大大缩短了查询并添加依赖的时间</li><li>内嵌容器支持：SpringBoot内嵌了Tomcat、Jetty、Undertow</li><li>Actuator监控：可以监控应用程序的运行状况，或者内存、线程池、Http请求统计等</li></ul><ol start="7"><li>SpringBootApplication引入了哪3个重要注解?</li></ol><ul><li>核心注解是@SpringBootApplication，它主要由@SpringBootConfiguration，@EnableAutoConfiguration和@ComponentScan这三个构成：<br>  @SpringBootConfiguration 里面就只有一个 @Configuration 主要注解，也就是把该类变成一个配置类所以@SpringBootConfiguration 就相当于 @Configuration<br>  @EnableAutoConfiguration 是由 @AutoConfigurationPackage 和@Import(EnableAutoConfigurationImportSelector.class) 这两个组成的 @AutoConfigurationPackage 是自动配置包，包括了一个 @Import 注解，给容器导入了自动配置包的注册器，AutoConfigurationPackages.Registrar.class：将主启动类的所在包及包下面所有子包里面的所有组件扫描到 Spring 容器<br>  @ComponentScan：扫描包，该注解默认会扫描该类所在的包下所有的配置类</li></ul><ol start="8"><li>SpringBoot的配置文件由哪几种格式？它们有什么区别？<br> 主要有.properties 和 .yml，它们的区别主要是写的格式不同：<pre><code> .properties： user.name = jason .yml： user:     name: javastack .yml 格式不支持 @PropertySource 注解导入配置</code></pre></li><li>SpringBoot需要独立的容器运行吗？</li></ol><ul><li>不需要，因为已经内置了 Tomcat/ Jetty 等容器</li></ul><ol start="10"><li>你如何理解 Spring Boot 中的 Starters</li></ol><ul><li>个人理解 Spring Boot 就是由各种 Starter 组合起来的，我们自己也可以开发Starter。</li><li>当一个项目变得相当复杂，管理依赖会成为一个噩梦，因为当中涉及太多 artifacts 了。</li><li>这时候 SpringBoot starter 就派上用处了。其他所需的依赖以一致的方式注入并且被管理。</li><li>所有的 starter 都归于 org.springframework.boot 组中，并且它们都以由 spring-boot-starter- 开头取名。这种命名方式使得我们更容易找到 starter 依赖，特别是当我们使用那些支持通过名字查找依赖的 IDE 当中。</li><li>SpringBoot 提供了非常多的 starter ，其中最常用的是：</li><li>spring-boot-starter：核心 starter，包括自动化配置支持，日志以及 YAML</li><li>spring-boot-starter-aop：Spring AOP 和 AspectJ 相关的切面编程 starter</li><li>spring-boot-starter-data-jpa：使用 Hibernate Spring Data JPA 的 starter</li><li>spring-boot-starter-jdbc：使用 HikariCP 连接池 JDBC 的 starter</li><li>spring-boot-starter-security：使用 Spring Security 的 starter</li><li>spring-boot-starter-test：SpringBoot 测试相关的 starter</li><li>spring-boot-starter-web：构建 restful、springMVC 的 web应用程序的 starter</li></ul><ol start="11"><li>Spring Boot 可以兼容老 Spring 项目吗，如何做？</li></ol><ul><li>使用 @ImportResource 注解导入老 Spring 项目配置文件</li></ul><ol start="12"><li>Spring Boot 中读取配置的方式有哪些？</li></ol><ul><li>注入Environment对象：通过Environment 的 getProperty() 方法读取指定配置 Key 的内容</li><li>使用@Value注解，实现单个配置的注入</li><li>使用@ConfigurationProperties注解，实现一组配置的注入</li></ul><ol start="13"><li>SpringBoot 实现热部署有哪几种方式？ 热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中 主要有两种方式：</li></ol><ul><li>SpringLoaded</li><li>Spring-boot-devtools</li></ul><ol start="14"><li>Spring Boot 是否可以使用 XML 配置 ?</li></ol><ul><li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过@ImportResource 注解可以引入一个 XML 配置</li></ul><ol start="15"><li>如何实现 Spring Boot 应用程序的安全性？</li></ol><ul><li>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法</li></ul><ol start="16"><li>运行 Spring Boot 有哪几种方式？</li></ol><ul><li>打包用命令或者放到容器中运行</li><li>用 Maven/ Gradle 插件运行</li><li>直接执行 main 方法运行</li></ul><ol start="17"><li>开启 Spring Boot 特性有哪几种方式</li></ol><ul><li>继承spring-boot-starter-parent项目</li><li><parent>    <groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter-parent</artifactid>    <version>2.6.2</version>    <relativepath> <!-- lookup parent from repository --></relativepath></parent></li><li>导入spring-boot-dependencies项目依赖</li><li><parent>  <groupid>org.springframework.boot</groupid>  <artifactid>spring-boot-dependencies</artifactid>  <version>2.6.2</version></parent></li></ul><ol start="18"><li>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪一个？</li></ol><ul><li>Spring Boot 支持 Logging、Log4j2、Lockback 做为日志框架，若是你使用 Starters 启动器，Spring Boot 将使用 Logback 做为默认日志框架</li></ul><ol start="19"><li>Spring Initializr 是创建 Spring Boot 的唯一方法？</li></ol><ul><li>Spring Initiatlizr 让创建 Spring Boot 项目变的很容易，但是，也可以通过设置一个 maven 项目并添加正确的依赖项来开始一个项目</li><li>创建方式有两种：</li><li>第一种:：start.spring.io 方式创建</li><li>第二种：在项目的标题为 “Basic Web Application” 处进行手动设置</li></ul><ol start="20"><li>Spring Boot 内嵌了 Tomcat ，那什么是嵌入式服务器</li></ol><ul><li>我们在虚拟机上面部署应用程序需要几个步骤：</li><li>安装 Java</li><li>安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</li><li>部署应用程序 jar 或者 war 包</li><li>如果把这些步骤简化了，应该怎么做呢？</li><li>让我们来思考如何使服务器成为应用程序的一部分？</li><li>我们只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了</li><li>这就是嵌入式服务器的起源</li></ul><ol start="21"><li>前后端分离，如何维护接口文档<br>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便</li><li>Spring Boot中如何解决跨域问题？</li></ol><ul><li><p>跨域可以在前端通过JSONP来解决，但是JSONP只可以发送GET请求，无法发送其他类型的请求，在RESTful风格的应用中，就显得非常鸡肋，因此推荐在后端通过（CORS，Cross-origin resource sharing）来解决跨域问题。这种解决方案并非Spring Boot特有的，在传统的SSM框架中，就可以通过CORS来解决跨域问题，只不过之前我们是在XML文件中配置CORS，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题</p></li><li><p>@Configuration<br>public class CorsConfig implements WebMvcConfigurer {</p><p>  @Override<br>  public void addCorsMappings(CorsRegistry registry) {</p><pre><code>  registry.addMapping("/**")          .allowedOrigins("*")          .allowCredentials(true)          .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")          .maxAge(3600);</code></pre><p>  }</p></li></ul><p>}</p><ul><li><p>项目中前后端分离部署，所以需要解决跨域的问题。</p></li><li><p>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。</p></li><li><p>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。</p></li><li><p>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行</p></li><li><p>@Configuration<br>public class CorsConfig {</p><pre><code>@Beanpublic CorsFilter corsFilter() {    CorsConfiguration corsConfiguration = new CorsConfiguration();    corsConfiguration.addAllowedOrigin("*");    corsConfiguration.addAllowedHeader("*");    corsConfiguration.addAllowedMethod("*");    corsConfiguration.setAllowCredentials(true);    UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();    urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);    return new CorsFilter(urlBasedCorsConfigurationSource);}</code></pre><p>}</p></li></ul><ol start="23"><li>Spring Boot 约定优于配置的体现是什么？</li></ol><ul><li>Maven的目录结构：<ul><li>默认有 resources 文件夹存放配置文件</li><li>默认打包方式为jar</li><li>默认的配置文件：application.properties 或 application.yml 文件</li><li>默认通过 spring.profiles.active 属性来决定运行环境时的配置文件</li><li>EnableAutoConfiguration 默认对于依赖的 starter 进行自动装载</li><li>spring-boot-start-web 中默认包含 spring-mvc 相关依赖以及内置的 tomcat 容器，使得构建一个 web 应用更加简单</li></ul></li></ul><ol start="24"><li>内置容器的启动流程是什么</li></ol><ul><li>启动一个 Spring Boot项目，首先运行 Application 启动类的 main 方法，main 方法中调用了 SpringApplication.run 方法，run 方法中又调用了最核心的 refreshContext 方法，这里面又调用了我们最熟悉了 spring 容器启动模板方法refresh 方法，默认 Spring Boot 会启动 Tomcat，在 refresh 中的 onRefresh() 中执行；<br>onRefresh 调用了 createWebServer() 方法，通过 TomcatServletWebServerFactory 开始创建 Tomcat 实例；<br>最后在 refresh 方法中的 finishRefresh() 中调用 Tomcat 实例的 start 逻辑，并将应用上下文发布的 webServer 中，至此完成 Tomcat 的启动</li></ul><ol start="25"><li>你如何理解 Spring Boot 配置加载顺序？</li></ol><ul><li>Spring Boot 配置加载顺序优先级是:propertiese文件、YAML文件、系统环境变量、命令行参数。</li></ul><ol start="26"><li>application.properties 和 bootstrap.properties 有何区别 ?</li></ol><ul><li>bootstrap 比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效, 而且 boostrap 里面的属性不能被覆盖；<br>application 用于 Spring Boot 项目的自动化配置</li></ul><ol start="27"><li>Spring Boot 中的监视器是什么？</li></ol><ul><li>Spring boot actuator 是 spring 启动框架中的重要功能之一，Spring boot 监视器可以访问生产环境中正在运行的应用程序的当前状态。监视器模块公开了一组可直接作为 HTTP URL 访问的 REST 端点来检查状态</li></ul><ol start="28"><li>如何使用 Spring Boot 实现异常处理？</li></ol><ul><li>Spring 通过使用 @ControllerAdvice 注解处理异常，实现一个ControllerAdvice 类来处理控制器类抛出的所有异常</li></ul><ol start="29"><li>YAML在springboot中的作用</li></ol><ul><li>使得 Spring Boot 配置文件更加有层次感，结构也比较清晰，不容易混淆，目前也是人类可读的数据序列化语言</li></ul><ol start="30"><li><p>如何使用 SpringBoot 实现分页和排序？<br>1、pom</p><!--分页插件--><pre><code>      &lt;dependency&gt;          &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;          &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;${pagehelper-version}&lt;/version&gt;      &lt;/dependency&gt;</code></pre><ul><li><p>配置文件<br>pagehelper:<br>helper-dialect: mysql<br>reasonable: true<br>support-methods-arguments: true<br>params: count=countSql</p></li><li><p>service层<br>   //用插件进行分页<br>   PageHelper.startPage(pageNum, pageSize);<br>   return articleMapper.findByPage();    </p></li><li><p>controller层<br>　　　　　通过service调用方法后获取数据。<br>　　　　　// 需要把Page包装成PageInfo对象才能序列化。该插件也默认实现了一个PageInfo<br>   PageInfo</p><article> pageInfo = new PageInfo&lt;&gt;(articles);</article><p></p></li></ul></li><li><p>Spring Boot 中如何实现定时任务 ?</p></li></ol><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li><li>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可</li></ul><ol start="32"><li>你使用了哪些 starter maven 依赖项？</li></ol><ul><li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li><li>spring-boot-starter-data-jpa 数据库支持</li><li>spring-boot-starter-data-Redis Redis数据库支持</li><li>spring-boot-starter-data-solr solr支持</li><li>mybatis-spring-boot-starter 第三方的mybatis集成starter<br>自己开发过的都可以说出来</li></ul><ol start="33"><li>Spring Boot 自动配置的原理</li></ol><ul><li>SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration</li><li>查看@EnableAutoConfiguration，其作用是利用AutoConfigurationImportSelector给容器中导入一些组件</li><li>查看AutoConfigurationImportSelector，其中public String[] selectImports(AnnotationMetadata annotationMetadata)方法内 最终调用getCandidateConfigurations()方法</li><li>查看 getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)，获取候选的配置，这个是扫描所有jar包类路径下”META-INF/spring.factories”</li><li>然后把扫描到的这些文件包装成Properties对象</li><li>从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把他们添加在容器中</li><li>整个过程就是将类路径下 “META-INF/spring.factories” 里面配置的所有 EnableAutoConfiguration 的值加入到容器中</li></ul><ol start="34"><li>SpringBoot核心配置文件是什么？</li></ol><ul><li>bootstrap.properties 和 application.properties</li></ul><ol start="35"><li><p>如何监视所有 SpringBoot 微服务？<br>创建SpringBoot Web项目，引入下列pom坐标</p><dependency>  <groupid>de.codecentric</groupid>  <artifactid>spring-boot-admin-starter-server</artifactid>  <version>2.5.1</version></dependency><dependency><h1 id="在你的启动类上添加：-EnableAdminServer注解"><a href="#在你的启动类上添加：-EnableAdminServer注解" class="headerlink" title="在你的启动类上添加：@EnableAdminServer注解"></a>在你的启动类上添加：@EnableAdminServer注解</h1><p>在你需要监控的服务中加入下列pom坐标</p><dependency> <groupid>de.codecentric</groupid> <artifactid>spring-boot-admin-starter-client</artifactid> <version>2.5.1</version></dependency><p>在需监控服务中配置：<br>spring.boot.admin.client.url=<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> （监控服务url）<br>management.endpoints.web.exposure.include=*</p></dependency></li><li><p>Spring Boot 打成的 jar 和普通的 jar 有什么区别</p></li></ol><ul><li>Spring Boot 打成jar包可以直接通过 java -jar *.jar 启动项目，但是不能够像普通 jar 包一样被其他项目引用。</li><li>普通 jar 解压后就是包名，可以直接引用内部的类，而 Spring Boot 解压后 BOOT/classes 目录下才是真正的代码，因此不能被直接引用，如果需要被引用可以配置 pom，将 SpringBoot 打包成两个 jar 包，一个可执行，一个可引用</li></ul><table>  <tbody><tr>    <td><img width="100" src="/medias/avatars/Echarts.png"></td>    </tr></tbody></table><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>        <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/2024/01/20/blog-open-source/"/>
      <url>/2024/01/20/blog-open-source/</url>
      
        <content type="html"><![CDATA[<h1 id="vue封装数据发送后台"><a href="#vue封装数据发送后台" class="headerlink" title="vue封装数据发送后台"></a>vue封装数据发送后台</h1><pre><code>可以使用将数据转换为JSON格式或者使用FormData对象封装数据(键值对)键对应后台的实体类,值前端要传入后台的值    JSON:                             const data = {                     name: 'John',                    age: 25,                        };    JSON.stringify(data)    FormData:    const formData = new FormData();    formData.append('name', 'John');    formData.append('age', 25);</code></pre><hr><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>1.创建一个表单并添加一个文件输入控件，例如使用<code>&lt;input type="file"&gt;</code>元素。<br>2.监听文件选择事件，获取用户选择的文件，并将其存储在Vue组件的data属性中。<br>3.通过FormData（表单数据对象）来构造包含上传文件的表单数据。<br>4.发送POST请求到服务器，携带表单数据，以此来完成文件上传操作。<br>后端，我们使用了Spring Boot框架和Spring MVC来处理文件上传。通过@RequestParam注解来获取上传的文件，MultipartFile对象包含了文件的各种信息和操作方法。我们使用getBytes()方法获取文件的字节数组，然后使用Files.write()方法将文件写入目标路径。</p><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p>1.<code>beforeCreate</code>：实例刚被创建，数据观测和事件配置之前，此时无法访问到data和methods等实例属性。<br>2.<code>created</code>：实例已经被创建，数据观测和事件配置完成，此时可以访问到data和methods等实例属性，但未挂载到DOM上。<br>3.<code>beforeMount</code>：在挂载开始之前被调用，此时模板编译已完成，但DOM还未生成。<br>4.<code>mounted</code>：实例已经挂载到DOM上，此时可以对DOM进行操作，访问到挂载的元素。<br>5.<code>beforeUpdate</code>：数据更新时，重新渲染之前被调用，此时数据已经更新，但DOM尚未重新渲染。<br>6.<code>updated</code>：数据更新并且DOM重新渲染完成后被调用。<br>7.<code>beforeDestroy</code>：实例销毁之前被调用，此时实例仍然完全可用。<br>8.<code>destroyed</code>：实例销毁后被调用，此时实例及其所有的事件监听器和观察者都被移除。<br>9.<code>beforeCreate</code>和<code>created</code>钩子函数会在组件实例化之前执行；<br>10.<code>beforeDestroy</code>和<code>destroyed</code>钩子函数会在组件销毁之前执行。</p><h1 id="vue权限控制"><a href="#vue权限控制" class="headerlink" title="vue权限控制"></a>vue权限控制</h1><p>当我们开发一个应用程序时，经常需要对用户的权限进行控制，以决定用户能够执行哪些操作或看到哪些内容。<br>首先，我们需要在Vue中注册这个自定义指令。指令是一种特殊的功能，可以在HTML标签中使用，用来控制元素的行为。在这个例子中，我们将指令名称设置为<code>permission</code>。<br>接下来，我们定义了指令的具体实现逻辑。当一个元素被插入到页面中时，指令会生效。在这个函数中，我们首先从浏览器的存储中（<code>sessionStorage</code>）获取用户的权限列表，这个列表中存储了用户拥有的权限信息。<br>然后，我们判断当前权限列表中是否包含了指令的绑定值（也就是所需的权限）。如果不包含，说明用户没有相应的权限。在这种情况下，我们会进行以下操作：<br>如果元素不是按钮，我们会将它隐藏起来，使用户无法看到它。<br>如果元素是按钮，我们会禁用它，使用户无法点击它。<br>此外，我们还给禁用的按钮添加了一个CSS类名<code>is-disabled</code>，通过添加这个类名，我们可以为禁用的按钮添加一些特定的样式。<br>最后，代码中还添加了一个自定义方法<code>contains</code>，用来判断一个数组是否包含某个特定的值。尽管在这段代码中没有使用到这个方法，但可能会在其他地方使用到它。<br>总的来说，这段代码实现了一个功能权限判断的指令。它通过用户的权限列表来控制应用程序中的元素是否可见或可操作，从而实现了权限控制的功能。</p><h1 id="spingmvc的一些注解"><a href="#spingmvc的一些注解" class="headerlink" title="spingmvc的一些注解"></a>spingmvc的一些注解</h1><p>1.@Controller：用于标识一个类为Spring MVC的控制器，可以处理HTTP请求并返回响应结果。<br>2.@RequestMapping：用于映射请求路径和控制器方法，支持路径变量、请求参数和HTTP方法等条件。<br>3.@PathVariable：用于获取URL中的路径变量，可以将其绑定到方法参数中。<br>4.@RequestParam：用于获取请求参数，可以将其绑定到方法参数中，并支持参数默认值、必填项和名称映射等配置。<br>5.@ResponseBody：用于标识方法返回的结果直接写入HTTP响应体中，而不是通过模板引擎渲染页面。<br>6.@ModelAttribute：用于在请求处理方法执行前将请求参数绑定到模型对象中，以便在视图中进行显示。<br>7.@SessionAttribute：用于将模型对象存储到会话中，以便多个请求之间共享数据。<br>8.@CookieValue：用于获取指定名称的cookie值，并将其绑定到方法参数中。<br>9.@InitBinder：用于定制数据绑定操作，例如对日期格式进行转换、防止XSS攻击等。<br>10.@ExceptionHandler：用于捕获控制器内部抛出的异常，并进行统一处理和返回错误信息。</p><h1 id="spingmvc返回数据到前端的几种方式"><a href="#spingmvc返回数据到前端的几种方式" class="headerlink" title="spingmvc返回数据到前端的几种方式"></a>spingmvc返回数据到前端的几种方式</h1><p>1.使用@ResponseBody注解：在控制器的方法上添加@ResponseBody注解，可以将方法的返回值直接写入HTTP响应体中。Spring MVC会自动将返回值转换为JSON、XML等格式，并设置正确的Content-Type头。<br>2.返回ModelAndView对象：ModelAndView是Spring MVC中常用的返回类型，它包含了要返回给视图的数据和视图名称。<br>3.使用Model和Map：可以在方法参数中添加Model或Map类型的参数，然后将数据存储到其中。Spring MVC会自动将这些数据传递给视图。<br>4.使用HttpServletRequest和HttpServletResponse：可以直接在方法参数中声明HttpServletRequest和HttpServletResponse对象，并使用它们进行数据读取和写入。</p><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro</title>
      <link href="/2024/01/20/shiro/"/>
      <url>/2024/01/20/shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro实现权限控制步骤"><a href="#Shiro实现权限控制步骤" class="headerlink" title="Shiro实现权限控制步骤"></a>Shiro实现权限控制步骤</h1><p>   1.加入3个依赖<br>       shiro-core（shiro内核依赖）<br>       shiro-spring(shiro与spring整合依赖)<br>       spring-boot-starter-aop(spring aop依赖)<br>   2.创建shiro对应的配置文件<br>      1.ShiroConfig(文件名称可以自定义，配置类),自动加载，并执行shiroFilter方法，排除不需要权限的URL<br>          同时启动注解功能（即运行authorizationAttributeSourceAdvisor方法）<br>          该类启动时执行一次，后面不再执行该类<br>      2.UserRealm(文件名称可以自定义，实现用户登录与权限控制)<br>   3.在需要进行权限控制的方法前面加上对应的注解<br>      @RequiresPermissions(“权限字符串”)<br>      当访问路径对应的方法前面有@RequiresPermissions注解时，系统自动调用UserRealm类的AuthorizationInfo方法进行权限验证，<br>      如果有权限那么程序正常执行，如果没有权限，系统会自动抛出异常,UserExceptionHandler类会自动处理异常<br>   4.创建全局异常处理类<br>      UserExceptionHandler:当用户点击没有权限的菜单（按钮）时，进行统一的异常处理，并返回错误信息<br>   5.对应5个表<br>      User表:用户表<br>      Role表：角色表<br>      user_role表:用户角色表<br>      permission表:系统权限表<br>      role_permission表:角色权限表</p><h1 id="设置不需要进行权限控制的路径-允许匿名访问"><a href="#设置不需要进行权限控制的路径-允许匿名访问" class="headerlink" title="设置不需要进行权限控制的路径(允许匿名访问)"></a>设置不需要进行权限控制的路径(允许匿名访问)</h1><pre><code>anon:允许匿名访问authc：需要进行身份认证的路径map.put("/login2/", "anon"); // 登录成功后的访问路径map.put("/login2/login", "anon"); // 登录操作map.put("/js/**", "anon"); // js文件路径map.put("/css/**", "anon"); // css文件路径map.put("/images/**", "anon"); // 图标文件路径map.put("/upload/**", "anon"); // 上传后的图片访问路径（MyMvcConfig类中配置的路径）map.put("/**", "authc"); // 进行身份认证后才能访问</code></pre><hr><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养老院管理系统</title>
      <link href="/2024/01/20/blog/"/>
      <url>/2024/01/20/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>随着人口老龄化趋势的加剧，养老问题已经成为全球面临的重大社会问题之一。在中国，老年人口数量庞大，养老需求迅速增长，但养老服务水平和质量普遍存在不足，尤其是养老机构管理问题。当前，许多养老机构存在管理混乱、服务质量低下、人才短缺等问题，不能及时满足老年人的需求，给老年人的身体和心理健康带来了很大的困扰。</p><p>因此，建立一套高效的养老院管理系统是非常必要的。该系统可以实现对养老机构的信息化管理，包括老人入住、床位管理、医疗护理、膳食管理、活动安排、员工考勤、财务管理等方面。通过系统优化管理流程，提高服务质量，满足老年人的需求，保障老年人的权益和福利。</p><hr><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>系统的目标和用途：</strong></p><ul><li>我们开发的后台系统旨在提供一个高效、可靠且易于管理的解决方案，以支持各种业务需求。<br>它是一个基于云架构的后台管理平台，用于管理和监控用户数据、处理业务逻辑以及支持关键决策。</li></ul><p><strong>系统的主要功能和特点：</strong></p><ul><li>我们的后台系统具备多个核心功能，包括用户管理、权限控制、数据存储与处理、业务逻辑实现、报表生成等。<br>它提供了一个直观友好的用户界面，使用户能够轻松地管理、操作和监控系统中的数据和业务流程。</li></ul><p><strong>系统采用的技术架构：</strong></p><ul><li>我们的后台系统采用了现代化的技术架构，使用了流行的编程语言和开发框架，如 <code>javaWeb语言</code>和 <code>SpingMvc框架</code>。<br>数据库方面，我们选择了高性能和可扩展的关系型数据库 <code>MySQL</code>。<br>系统的架构设计注重可扩展性、灵活性和高性能，以满足不断增长的用户需求。</li></ul><p><strong>各个模块和功能的介绍：</strong></p><ul><li>后台系统由多个模块组成，每个模块都承担着不同的功能。比如,用户管理模块用于管理用户信息和权限控制，<br>数据存储与处理模块负责数据的存储、处理和分析，业务逻辑实现模块用于实现具体的业务流程，报表生成模块能够生成丰富的报表和图表,订单管理模块用于管理物品或药品的采购,入库,领用等等。可以帮助管理员更好地管理和处理订单业务流程，提高订单处理效率和精度。同时，该模块还提供了丰富的报表和统计功能，以帮助管理员对订单数据进行分析和决策等。这些模块之间通过API进行交互，形成一个完整的后台系统。  </li></ul><p><strong>数据管理的方法和策略：</strong></p><ul><li>我们的后台系统采用了严格的数据管理方法和策略，确保数据的完整性和可靠性。<br>数据以结构化的方式存储在数据库中，并进行定  期备份和冗余存储。同时，我们也注重数据安全性，采取了多层次的访问控制和加密措施，以保护用户数据的安全。</li></ul><p><strong>性能优化措施：</strong></p><ul><li>为了提高系统的性能和响应速度，我们采取了多项性能优化措施。例如，对数据库查询进行优化，使用缓存技术加速数据访问，<br>优化代码以减少资源消耗等。这些措施使得系统能够处理大规模数据和高并发请求，保证系统的高效率和稳定性。</li></ul><p><strong>用户界面设计：</strong></p><ul><li>后台系统的用户界面经过精心设计，注重用户体验和易用性。它采用直观的布局和交互方式，<br>使用户能够快速上手并轻松完成各种 操作。用户界面提供了丰富的功能和操作方式，如数据查看、编辑、导出等，以满足不同用户的需求。</li></ul><p><strong>测试和部署：</strong></p><ul><li>为了保证系统的质量和稳定性，我们采用了全面的测试策略。包括单元测试、集成测试、自动化测试等多种测试方法，<br>以确保系统 在各种场景下都能正常运行。在部署方面，我们使用容器化技术和自动化部署流程，实现快速、可靠的系统部署。</li></ul><p><strong>成果和效益：</strong></p><ul><li>我们的后台系统已经取得了显著的成果和效益。通过提供高效的数据管理和业务流程支持，<br>我们帮助用户提升了工作效率，降低了成本，改进了决策过程。</li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://sunhwee.com/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://sunhwee.com/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 养老院管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingMvc </tag>
            
            <tag> ElementUi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
